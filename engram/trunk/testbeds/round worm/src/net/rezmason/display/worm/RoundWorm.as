package net.rezmason.display.worm {	import flash.display.*;	import flash.events.*;	import flash.geom.*;	public final class RoundWorm extends Shape {		private static const DEGREES_TO_RADIANS:Number = Math.PI / 180;		private static const TWO_PI:Number = Math.PI * 2;		private static const INVERSE_TWO_PI:Number = 1 / (Math.PI * 2);		private var _transform:RoundWormTransform;		private var _lastTransform:RoundWormTransform;		private var arcPoints:Array, beginPoints:Array, endPoints:Array;		private var _graphics:Graphics;		private var arcLength:Number;		public function RoundWorm(arg:* = null):void {			if (arg) {				if (arg is RoundWormTransform) {					_transform = arg.clone();				} else if (arg is Object) {					_transform = new RoundWormTransform();					_transform.thickness = arg.thickness;					_transform.length = arg.length;					_transform.curvature = arg.curvature;					_transform.color = arg.color;					_transform.wavelength = arg.wavelength;				}			} else {				_transform = new RoundWormTransform();			}			_lastTransform = new RoundWormTransform();			_lastTransform.crapOut();			_graphics = super.graphics;			listen(null, true);		}		public function squirm(distance:Number):void {						var newOffset:Number = _transform._offset + distance;			var reposition:int = (_transform._offset + distance) / (2 * arcLength);						if (newOffset < 0) {				while (newOffset < 0) {					_transform._offset += 2 * arcLength;					newOffset += 2 * arcLength;					x -= _transform._wavelength;				}			} else if (reposition) {				x += _transform._wavelength * reposition;			}						_transform._offset = (_transform._offset + distance) % (2 * arcLength);						redraw();		}		public function transformPoint(p:Point):Point {			return new Point();		}		public function get wormTransform():RoundWormTransform {			return _transform.clone();		}		public function set wormTransform(value:RoundWormTransform):void {			if (_transform.absorb(value)) {				listen();			}		}		public function redraw(event:Event = null):void {			listen(event, true);		}		override public function get graphics():Graphics {			return null;		}		private function listen(event:Event = null, forced:Boolean = false):void {			if (forced) {				update();			} else {				addEventListener(Event.ENTER_FRAME, update);			}		}		private function update(event:Event = null):void {						removeEventListener(Event.ENTER_FRAME, update);					if (!_transform._curvature) {				drawStraight();			} else if (_transform._curvature == RoundWormTransform.CURVATURE_LIMIT) {				drawDumb();			} else {				drawCurved();			}		}		private function drawStraight():void {			with (_transform) {				with (_graphics) {					clear();					if (_cornerRadius >= _length) {						if (_thickness > _cornerRadius) {							// worm is the beginning line							lineStyle(_cornerRadius, _color, 1, false, LineScaleMode.NORMAL, CapsStyle.ROUND);							moveTo(_offset + _cornerRadius * 0.5, -(_thickness * 0.5 - _cornerRadius * 0.5));							lineTo(_offset + _cornerRadius * 0.5, +(_thickness * 0.5 - _cornerRadius * 0.5));						} else {							// worm is a dot							beginFill(_color);							if (_length > _thickness) {								drawCircle(_offset + _length * 0.5, 0, _length * 0.5);							} else {								drawCircle(_offset + _thickness * 0.5, 0, _thickness * 0.5);							}							endFill();						}					} else if (_thickness > _cornerRadius) {						// worm is "normal"						lineStyle(_thickness, _color, 1, false, LineScaleMode.NORMAL, CapsStyle.NONE);						moveTo(_offset + _cornerRadius * 0.5, 0);						lineTo(_offset + _length - _cornerRadius * 0.5, 0);						if (_cornerRadius) {							// draw the beginning and ending lines							lineStyle(_cornerRadius, _color, 1, false, LineScaleMode.NORMAL, CapsStyle.ROUND);							// beginning line							moveTo(_offset + _cornerRadius * 0.5, -(_thickness * 0.5 - _cornerRadius * 0.5));							lineTo(_offset + _cornerRadius * 0.5, +(_thickness * 0.5 - _cornerRadius * 0.5));							// ending line							moveTo(_offset + _length - _cornerRadius * 0.5, -(_thickness * 0.5 - _cornerRadius * 0.5));							lineTo(_offset + _length - _cornerRadius * 0.5, +(_thickness * 0.5 - _cornerRadius * 0.5));						}					} else if (_cornerRadius) {						// worm is thin, but still wavy						lineStyle(_cornerRadius, _color, 1, false, LineScaleMode.NORMAL, CapsStyle.ROUND);						moveTo(_offset + _cornerRadius * 0.5, 0);						lineTo(_offset + _length - _cornerRadius * 0.5, 0);					}				}			}		}				private function drawDumb():void {			// this should draw a straight line from offset to offset - length 		}		private function drawCurved():void {						with (_transform) {								// var declaration is expensive.				// note that, if _transform._thickness changes, none of this has to be recalculated.								var curveInRads:Number = _curvature * DEGREES_TO_RADIANS; 			// _curvature				var spacing:Number = _wavelength * 0.25; 							// _wavelength								var radius:Number = spacing / Math.sin(curveInRads * 0.5); 			// _curvature _wavelength				var h:Number = spacing / Math.tan(curveInRads * 0.5); 				// _curvature _wavelength				arcLength = radius * curveInRads; 									// _curvature _wavelength				var numSegments:int = int(1 + (_length + _offset) / arcLength); 	// _curvature _wavelength _length _offset				var beginning:int = int(_offset / arcLength); 						// _curvature _wavelength _offset				var ending:int = int((_offset + _length) / arcLength); 				// _curvature _wavelength _length _offset								var xOffset:Number, yOffset:Number;				var _swap:Number = 1;				var beginAngle:Number, endAngle:Number;				var ratio:Number;				var flip:Number;				var ike:int, jen:int;									with (_graphics) {										clear();										lineStyle(Math.min(Math.max(_thickness, _cornerRadius), radius * 2), _color, 1, false, LineScaleMode.NORMAL, CapsStyle.NONE);										// if the worm begins and ends on the same arc segment,					if (beginning == ending) {												xOffset = spacing * (2 * beginning + 1);						yOffset = h * _polarity;												flip = (beginning % 2) ? -1 : 1;												// draw a beginning-ending arc where appropriate												beginAngle = _length / arcLength * _curvature;												ratio = (0.5 - (_offset % arcLength) / (arcLength - (_length % arcLength))) * _polarity;												beginPoints = getArc(xOffset, yOffset, radius, beginAngle, 90 * _polarity - beginAngle * (ratio + 0.5) + _curvature * ratio, true);												moveTo(beginPoints[0][0], beginPoints[0][1] * flip);												for (ike = 1; ike < beginPoints.length; ike) {							if (_shortcut) {								lineTo(beginPoints[++ike][0], beginPoints[ike++][1] * flip);							} else {								curveTo(beginPoints[ike][0], beginPoints[ike++][1] * flip, beginPoints[ike][0], beginPoints[ike++][1] * flip);							}						}											} else {												// draw an ending arc												xOffset = spacing * (2 * ending + 1);						yOffset = h * _polarity;												flip = (ending % 2) ? -1 : 1;												endAngle = ((_length + _offset) % arcLength) / arcLength * _curvature;												endPoints = getArc(xOffset, yOffset, radius, endAngle, endAngle * 0.5 * (-_polarity - 1) + (90 + _curvature * 0.5) * _polarity, true);												if (_polarity < 0) {							endPoints.reverse();						}												moveTo(endPoints[0][0], endPoints[0][1] * flip);												for (ike = 1; ike < endPoints.length; ike) {							if (_shortcut) {								lineTo(endPoints[++ike][0], endPoints[ike++][1] * flip);							} else {								curveTo(endPoints[ike][0], endPoints[ike++][1] * flip, endPoints[ike][0], endPoints[ike++][1] * flip);							}						}												// draw the middle arcs												arcPoints = getArc(0, 0, radius, _curvature, 90 - _curvature * 0.5);												for (jen = ending - 1; jen > beginning; jen--) {														xOffset = spacing * (2 * jen + 2);														flip = _polarity * ((jen % 2) ? -1 : 1);														for (ike = 1; ike < arcPoints.length; ike) {								if (_shortcut) {									lineTo(arcPoints[++ike][0] + xOffset, arcPoints[ike++][1] * flip);								} else {									curveTo(arcPoints[ike][0] + xOffset, arcPoints[ike++][1] * flip, arcPoints[ike][0] + xOffset, arcPoints[ike++][1] * flip);								}							}						}												// draw a beginning arc												xOffset = spacing * (2 * beginning + 1);						yOffset = h * _polarity;												flip = (beginning % 2) ? -1 : 1;												beginAngle = (arcLength - (_offset % arcLength)) / arcLength * _curvature;												beginPoints = getArc(xOffset, yOffset, radius, beginAngle, beginAngle * 0.5 * (+_polarity - 1) + (90 - _curvature * 0.5) * _polarity, true);												if (_polarity < 0) {							beginPoints.reverse();						}												for (ike = 1; ike < beginPoints.length; ike) {							if (_shortcut) {								lineTo(beginPoints[++ike][0], beginPoints[ike++][1] * flip);							} else {								curveTo(beginPoints[ike][0], beginPoints[ike++][1] * flip, beginPoints[ike][0], beginPoints[ike++][1] * flip);							}						}					}				}			}		}		private function getArc(centerX:Number, centerY:Number, radius:Number, arc:Number, startAngle:Number, stayOnCircle:Boolean = false):Array {						// Mad props to Ric Ewing: formequalsfunction.com						// var declaration is expensive						var returnValue:Array = [];			var segs:int, segAngle:Number;			var theta:Number, angle:Number, angleMid:Number;			var ax:Number, ay:Number, bx:Number, by:Number, cx:Number, cy:Number;			var xOffset:Number = centerX, yOffset:Number = centerY;					if (arc < 0) {				throw new Error("Don't pass me an arc < 0");			}					segs = arc * 0.02222 + 1;			segAngle = arc / segs;					theta = -segAngle * DEGREES_TO_RADIANS;			angle = -startAngle * DEGREES_TO_RADIANS;					ax = -Math.cos(angle) * radius;			ay = -Math.sin(angle) * radius;					if (stayOnCircle) {				returnValue.push([centerX - ax, centerY - ay]);				ax = 0;				ay = 0;			} else {				returnValue.push([xOffset, yOffset]);			}					while (segs--) {				angle += theta;				angleMid = angle - (theta * 0.5);				bx = ax + Math.cos(angle) * radius;				by = ay + Math.sin(angle) * radius;				cx = ax + Math.cos(angleMid) * (radius / Math.cos(theta / 2));				cy = ay + Math.sin(angleMid) * (radius / Math.cos(theta / 2));				returnValue.push([cx + xOffset, cy + yOffset], [bx + xOffset, by + yOffset]);			}					return returnValue;		}	}}