package net.rezmason.display {		// IMPORT STATEMENTS	import flash.display.BitmapData;	import flash.display.Shape;	import flash.display.Sprite;	import flash.geom.Rectangle;		/**	*	ColorSprite that automatically applies a texture to itself.	*		*	@author Jeremy Sachs	*	@langversion	ActionScript 3.0	*	@playerversion	Flash 9	*	@tiptext	*/	public class Applicator extends DisplayAbstract {				// CLASS PROPERTIES		/**		*	Setting an Applicator's width or height to AUTO		*	causes it to mask its child display objects.		*/		public static const AUTO:int = -1;						// INSTANCE PROPERTIES		private var _transparent:Boolean;		protected var _width:int = 0; 		protected var _height:int = 0;		private var lastRatio:Number = 1;		private var _rect:Rectangle = new Rectangle;		protected var output:BitmapData;		private var back:Shape = new Shape;		private var texture:Shape = new Shape;		private var cache:Sprite = new Sprite;				/**		*	Creates an Applicator object that you can use		*	to apply a texture to display information.		*			*	<p>If either of the first two parameters are unspecified,		*	the Applicator automatically applies its texture		*	to its contents, effectively masking them.</p>		*		*	@param	w	 The desired width of the Applicator.		*	@param	h	 The desired height of the Applicator.		*	@param	transparent	 Determines whether the texture is transparent.		*	@param	textureIndex	 The color palette index of the applied texture.		*	@param	backIndex	 The color palette index of the background color, if present.		*/		public function Applicator(w:int = AUTO, h:int = AUTO,		 	transparent:Boolean = false, textureIndex:int = 0, backIndex:int = 1):void {						super(DisplayAbstractEnforcer.INSTANCE);						if (w != AUTO && h != AUTO) {				_rect.width = _width = w;				_rect.height = _height = h;				if (_rect.width < 0) {					_rect.width *= -1;				}				if (_rect.height < 0) {					_rect.height *= -1;				}			}						_transparent = transparent;						addChild(back);			addChild(texture);						addColorChild(back, backIndex);			addColorChild(texture, textureIndex);						rethinkTexture();						if (_rect.width && _rect.height) {				redraw(_rect.width * lastRatio, _rect.height * lastRatio);			} else {				redraw(AUTO, AUTO);			}		}				// GETTERS & SETTERS				/**		*	The blend mode of the applied texture.		*		*/		public function get textureBlendMode():String {			return texture.blendMode;		}				/**		*	@private		*/		public function set textureBlendMode(value:String):void {			texture.blendMode = value;		}				/**		*	The opacity of the applied texture.		*		*/		public function get textureAlpha():Number {			return texture.alpha;		}				/**		*	@private		*/		public function set textureAlpha(value:Number):void {			texture.alpha = value;		}				// PUBLIC METHODS				/**		*	Regenerates the current texture and dimensions of the surface.		*	<p>If either of the two parameters are unspecified,		*	the Applicator automatically applies its texture		*	to its contents, effectively masking them.</p>		*			*	@param	w	 The desired width of the Applicator.		*	@param	h	 The desired height of the Applicator.		*		*/		public function redraw(w:int = AUTO, h:int = AUTO):void {			if (w == AUTO || h == AUTO) {				if (contains(cache)) {					removeChild(cache);				}								while (numChildren) {					cache.addChild(getChildAt(0));				}								addChild(back);				addChild(texture);								if (!cache.numChildren) {					return;				}								if (!_transparent) {					mask = cache;				}								addChildAt(cache, 0);								_rect = cache.getBounds(this);				_width = _rect.width;				_height = _rect.height;							} else {				_width  = w;				_height = h;			}						output = new BitmapData(_width, _height, true, 0x00000000);						with (back.graphics) {				clear();				if (!_transparent) {					beginFill(0xFFFFFF);					drawRect(0, 0, _width, _height);					endFill();				}			}						with (texture.graphics) {				clear();				beginBitmapFill(output);				drawRect(0, 0, _width, _height);				endFill();			}						redrawTexture();		}				/**		*	Redraws the texture, specifically in a way that increases its resolution		*		*/		public function rerez(ratio:Number = 1):void {			// the ratio had better not make the Applicator too large			if (_rect.width * ratio >= 2880 || _rect.height * ratio >= 2880) {				return;			}			if (ratio == lastRatio) {				return;			}			lastRatio = ratio;			// scale up the bitmap and cache			cache.scaleX = cache.scaleY = lastRatio;			redraw(_rect.width * lastRatio, _rect.height * lastRatio);			// scale yourself down			scaleX = scaleY = 1 / lastRatio;					}				// PRIVATE & PROTECTED METHODS				protected function rethinkTexture():void {					}				protected function redrawTexture():void {					}	}}