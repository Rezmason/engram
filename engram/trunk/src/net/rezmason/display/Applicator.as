package net.rezmason.display {		// IMPORT STATEMENTS	import flash.display.BitmapData;	import flash.display.Shape;	import flash.display.Sprite;	import flash.geom.Rectangle;		public class Applicator extends DisplayAbstract {				// CLASS PROPERTIES		public static const AUTO:int = -1;						// INSTANCE PROPERTIES		private var _transparent:Boolean;		protected var _width:int = 0, _height:int = 0;		private var lastRatio:Number = 1;		private var _rect:Rectangle = new Rectangle;		protected var output:BitmapData;		private var back:Shape = new Shape;		private var texture:Shape = new Shape;		private var cache:Sprite = new Sprite;		// CONSTRUCTOR		public function Applicator(w:int = AUTO, h:int = AUTO,		 	transparent:Boolean = false, textureIndex:int = 0, backIndex:int = 1):void {						super(DisplayAbstractEnforcer.INSTANCE);						if (w != AUTO && h != AUTO) {				_rect.width = _width = w;				_rect.height = _height = h;				if (_rect.width < 0) {					_rect.width *= -1;				}				if (_rect.height < 0) {					_rect.height *= -1;				}			}						_transparent = transparent;						addChild(back);			addChild(texture);						addColorChild(back, backIndex);			addColorChild(texture, textureIndex);						rethinkTexture();						if (_rect.width && _rect.height) {				redraw(_rect.width * lastRatio, _rect.height * lastRatio);			} else {				redraw(AUTO, AUTO);			}		}				// GETTERS & SETTERS				public function get textureBlendMode():String {			return texture.blendMode;		}				public function set textureBlendMode(value:String):void {			texture.blendMode = value;		}				public function get textureAlpha():Number {			return texture.alpha;		}				public function set textureAlpha(value:Number):void {			texture.alpha = value;		}				// PUBLIC METHODS				public function redraw(w:int = AUTO, h:int = AUTO):void {			if (w == AUTO || h == AUTO) {				if (contains(cache)) {					removeChild(cache);				}								while (numChildren) {					cache.addChild(getChildAt(0));				}								addChild(back);				addChild(texture);								if (!cache.numChildren) {					return;				}								if (!_transparent) {					mask = cache;				}								addChildAt(cache, 0);								_rect = cache.getBounds(this);				_width = _rect.width;				_height = _rect.height;							} else {				_width  = w;				_height = h;			}						output = new BitmapData(_width, _height, true, 0x00000000);						with (back.graphics) {				clear();				if (!_transparent) {					beginFill(0xFFFFFF);					drawRect(0, 0, _width, _height);					endFill();				}			}						with (texture.graphics) {				clear();				beginBitmapFill(output);				drawRect(0, 0, _width, _height);				endFill();			}						redrawTexture();		}				public function rerez(ratio:Number = 1):void {			// the ratio had better not make the Applicator too large			if (_rect.width * ratio >= 2880 || _rect.height * ratio >= 2880) {				return;			}			if (ratio == lastRatio) {				return;			}			lastRatio = ratio;			// scale up the bitmap and cache			cache.scaleX = cache.scaleY = lastRatio;			redraw(_rect.width * lastRatio, _rect.height * lastRatio);			// scale yourself down			scaleX = scaleY = 1 / lastRatio;					}				// PRIVATE & PROTECTED METHODS				protected function rethinkTexture():void {					}				protected function redrawTexture():void {					}	}}