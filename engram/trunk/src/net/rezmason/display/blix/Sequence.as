/** * blix Library 1.0: bitmap augmentation * by Jeremy Sachs 9/30/2007 * * I have no blog, yet. When I have one, visit it.  * Maybe by then I'll have a new blix library. * * You may distribute this class freely, provided it is not modified in any way (including * removing this header or changing the package path). * * jeremysachs@rezmason.net */  package net.rezmason.display.blix {		// IMPORT STATEMENTS	import flash.display.BitmapData;	import flash.display.Graphics;	import flash.display.Shape;	import flash.events.TimerEvent;	import flash.geom.Matrix;	import flash.geom.Rectangle;	import flash.geom.Point;	import flash.utils.Timer;	/**	* 	Class that handles the blitting process for blix objects.	*		*	<p>Sequence objects can only be positioned at integer x and y coordinates. This is to prevent	*	Flash from antialiasing the bitmap images.</p>	*		*	<p>Sequence is an abstract class- theoretically, you cannot declare a new Sequence instance.	*	However, this is only weakly enforced, and there are simple ways to make instances.</p>	* 	*	@author Jeremy Sachs	*	@langversion	ActionScript 3.0	*	@playerversion	Flash 9	*	@tiptext	*/	[Exclude(name="graphics", kind="property")]	public class Sequence extends Shape {				// CLASS PROPERTIES		internal static const KEY:String = "hackMeIfYouMust";				// INSTANCE PROPERTIES		private var calibrateEvent:BlixEvent = new BlixEvent(BlixEvent.CALIBRATED);		protected var _source:BitmapData;		protected var _rect:Rectangle;		private var init:Boolean = false;		protected var _registration:Point;		protected var dumbPoint:Point = new Point;		protected var maxFrames:int;		protected var gridWidth:int, gridHeight:int;		protected var frame:BitmapData, frame2:BitmapData;		private var _x:Number = 0, _y:Number = 0;		private var _dispatch:Boolean = false;				/**		* Calling the <code>Sequence</code> constructor throws an <code>ArgumentError</code>		*	exception. You <i>can</i>, however, call constructors for the following		*	subclasses of Sequence:		*	<ul>		*	<li><code>new MovingSequence()</code></li>		*	<li><code>new SpinningSequence()</code></li>		*	</ul>		*			*/		public function Sequence(key:String, source:BitmapData, rect:Rectangle, 		reg:Point = null, dispatch:Boolean = false):void {			/* This key system "prevents" classes from instantiating Sequence			 * in the public namespace.			 */			if (key != KEY) {				throw new ArgumentError("ArgumentError: Error #2012: Sequence class cannot be instantiated.");			}			_source = source;			_rect = rect;			_dispatch = dispatch;			if (!reg) {				reg = new Point(_rect.width/2, _rect.height/2);			}			_registration = reg;			calibrate();			// initiation			drawFrame(0);			cacheAsBitmap = true;		}				// GETTERS & SETTERS				/**		* The total number of frames in the sequence.		*		*/		public function get totalFrames():int {			return maxFrames;		}				override public function get graphics():Graphics {			/* Access to Sequence's graphics object is prevented once its			 * constructor is finished.			 */			if (!init) {				return super.graphics;			} else {				return null;			}		}				/**		* A copy of the current frame.		*		*/		public function get frameBitmapData():BitmapData {			// returning a reference to the real source data would split the class open			return frame.clone();		}				/**		* The dimensions of a frame in the sequence sheet.		*		*/		public function get rect():Rectangle {			return _rect.clone();		}				/**		*	@private		*/		public function set rect( r:Rectangle ):void { 			_rect = r; 			calibrate();		}				/**		* The center of the object relative to the sequence frame.		*		*/		public function get registrationPoint():Point {			return _registration.clone();		}				/**		*	@private		*/		public function set registrationPoint( p:Point ):void {			_registration = p.clone();			calibrate();		}				override public function get x():Number {			return _x;		}				override public function set x (n:Number):void {			if (!isNaN(n)) {				_x = n;				super.x = int(n);			}		}				override public function get y():Number {			return _y;		}				override public function set y (n:Number):void {			if (!isNaN(n)) {				_y = n;				super.y = int(n);			}		}				/**		* The source sequence sheet.		*		*/		public function get bitmapData():BitmapData {			return _source;		}				/**		*	@private		*/		public function set bitmapData( bd:BitmapData ):void { 			_source = bd;			calibrate();		}				// PUBLIC METHODS				/**		* Copies the current frame to a target BitmapData object.		*	@param	target	 The destination BitmapData object.		*	@param	destPoint	 The destination point that represents the upper-left corner of the frame.		*		*/		public function copyPixelsTo(target:BitmapData, destPoint:Point = null):void {			// not sure if this will ever be used, but oh well.			if (!destPoint) {				destPoint = dumbPoint.clone();			}			destPoint.x += x, destPoint.y += y;			target.copyPixels(frame, frame.rect, destPoint);		}				// PRIVATE & PROTECTED METHODS				private function calibrate():void {			init = false;						// bitmap setup			frame = new BitmapData(_rect.width, _rect.height, true, 0);			frame2 = frame.clone();			graphics.clear();			graphics.beginBitmapFill(frame, new Matrix(1, 0, 0, 1, -_registration.x, -_registration.y), false, false);			graphics.drawRect(-_registration.x, -_registration.y, _rect.width, _rect.height);			graphics.endFill();			// grid check, frame counting			gridWidth = 0;			while ((gridWidth + 1) * _rect.width <= _source.width)			{				gridWidth++;			}			gridHeight = 0;			while ((gridHeight + 1) * _rect.height <= _source.height)			{				gridHeight++;			}			maxFrames = gridWidth * gridHeight;						if (_dispatch) {				dispatchEvent(calibrateEvent);			}			init = true;		}				protected function drawFrame(f:int, m:Matrix = null):void {			frame.lock();			frame.fillRect(frame.rect, 0);			_rect.x = (f % gridWidth) * _rect.width;			_rect.y = (f - (f % gridWidth)) / gridWidth * _rect.height;			if (m) {				// uses copyPixels when possible				frame2.copyPixels(_source, _rect, dumbPoint);				frame.draw(frame2, m);			} else {				// if there's a matrix parameter, it has to use draw				frame.copyPixels(_source, _rect, dumbPoint);			}			frame.unlock();		}	}}