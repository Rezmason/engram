package net.rezmason.display {		// IMPORT STATEMENTS	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.geom.ColorTransform;		/**	*	Sprite that maintains a list of children and compatible Objects	*	to colorize.	*	<p>Chains of <code>ColorSprite</code>s converge at a root node.	*	When a <code>ColorSprite</code>'s color palette is modified, 	*	it passes those modifications on to its colorized children.</p>	*		*	@author Jeremy Sachs	*	@langversion	ActionScript 3.0	*	@playerversion	Flash 9	*	@tiptext	*/	public class ColorSprite extends Sprite {				// CLASS PROPERTIES		private static const PLAIN_CT:ColorTransform = new ColorTransform;		private static const GRRR:String = "The supplied DisplayObject must be a colorChild of the caller.";		private static const GUEST_GRRR:String = "The supplied Object must be a colorGuest of the caller.";		private static const SET_COLORS_GRRR:String = "The supplied Object must have a valid setColors() function.";		private static const ARGUMENT_ERROR:ArgumentError = new ArgumentError(GRRR);		private static const ARGUMENT_GUEST_ERROR:ArgumentError = new ArgumentError(GUEST_GRRR);		private static const SET_COLORS_ERROR:Error = new Error(SET_COLORS_GRRR);				// INSTANCE PROPERTIES		public var colorizeEnabled:Boolean = false;		public var colorizeChildren:Boolean = true;		public var colorizeGuests:Boolean = true;		private var _colorChildren:Array = [], _colorChildIndices:Array = [];		private var _colorGuests:Array = [], _colorGuestIndices:Array = [];		private var setColorEvent:ColorEvent = new ColorEvent(ColorEvent.SET_COLOR);		private var _colorTransforms:Array = [];		private var _touched:Boolean = false;				/**		*	Creates a new <code>ColorSprite</code> instance.		*		*/		public function ColorSprite():void {			//addEventListener(ColorEvent.SET_COLOR, setColorsFromEvent);		}				// GETTERS & SETTERS				/**		*	The number of objects that will receive color information 		*	from the <code>ColorSprite</code> instance.		*		*/		public function get numColorChildren():int {			return _colorChildren.length;		}				/**		*	An array of the child color objects, in the order that they are colored.		*		*/		public function get colorChildren():Array {			return _colorChildren.slice();		}				/**		*	An array of the child color indices, in the order that the children are colored.		*		*/		public function get colorChildIndices():Array {			return _colorChildIndices.slice();		}				/**		*	The number of guest objects that will receive color information		*	from the <code>ColorSprite</code> instance.		*	<p>Color guests are different from color children in that they can exist in a different sandbox		*	than their color parent. Objects that can be color guests must have a setColors() method.</p>		*		*/		public function get numColorGuests():int {			return _colorGuests.length;		}				/**		*	An array of the guest color objects, in the order that they are colored.		*		*/		public function get colorGuests():Array {			return _colorGuests.slice();		}				/**		*	An array of the guest color indices, in the order that they are colored.		*		*/		public function get colorGuestIndices():Array {			return _colorGuestIndices.slice();		}				// PUBLIC METHODS				/**		*	Adds a child color object to this <code>ColorSprite</code>.		*	<p>Any compatible display object can be added to a <code>ColorSprite</code>.</p> 		*			*	@param	child	 DisplayObject to add to the color palette hierarchy		*	@param	pIndex	 Index of the color child's specified color.		*/		public function addColorChild(child:DisplayObject, pIndex:int = 0):void {			var oldAlpha:Number;						if (colorOfChild(child) != -1) {				removeColorChild(child);			}						_colorChildren.push(child);			_colorChildIndices.push(pIndex);						if (_colorTransforms && _colorTransforms.length) {				if (child is ColorSprite) {					(child as ColorSprite).setColors(_colorTransforms, pIndex);				} else {					pIndex = Math.max(0, Math.min(_colorTransforms.length - 1));					oldAlpha = child.alpha;					child.transform.colorTransform = _colorTransforms[pIndex];					child.alpha = oldAlpha;				}			}		}				/**		*	Adds a guest color object to this <code>ColorSprite</code>.		*			*	@param	obj	 A compatible Object to add to the color palette hierarchy.		*	@param	pIndex	 Index of the color child's specified color.		*/		public function addColorGuest(obj:Object, pIndex:int = 0):void {			try {				if (!obj.setColors || !obj.setColors is Function) {					throw SET_COLORS_ERROR;				}			} catch (error:Error) {				throw SET_COLORS_ERROR;			}						if (colorOfChild(obj, false) != -1) {				removeColorGuest(obj);			}						_colorGuests.push(obj);			_colorGuestIndices.push(pIndex);						if (_colorTransforms && _colorTransforms.length) {				obj.setColors(_colorTransforms, pIndex);			}		}				/**		*	Removes the specified child color object 		*	from the child list of the <code>ColorSprite</code> instance. 		*			*	@param	child	 The color child to remove.		*/		public function removeColorChild(child:DisplayObject):void {			var ike:int = _colorChildren.indexOf(child);			if (ike != -1) {				_colorChildren.splice(ike, 1);				_colorChildIndices.splice(ike, 1);				child.transform.colorTransform = PLAIN_CT;			} else {				throw ARGUMENT_GUEST_ERROR;			}		}				/**		*	Removes the specified guest color object		*	from the guest list of the <code>ColorSprite</code> instance. 		*			*	@param	obj	 The color object to remove.		*/		public function removeColorGuest(obj:Object):void {			if (!obj) {				throw new ArgumentError("removeColorGuest() does not accept a null value.");			}			var ike:int = _colorGuests.indexOf(obj);			if (ike != -1) {				_colorGuests.splice(ike, 1);				_colorGuestIndices.splice(ike, 1);				obj.setColors();			} else {				throw ARGUMENT_ERROR;			}		}				/**		*	Sets the color palette of the <code>ColorSprite</code>,		*	which it applies to itself or to its children or guests.		*			*	@param	colorTransforms	 An Array of color hex values or ColorTransform objects		*	that make up the color palette.		*	@param	myIndex	 The index of the color in the <code>colorTransforms</code> Array		*	to apply to the <code>ColorSprite</code>.		*/		public function setColors(colorTransforms:Array, myIndex:int = 0):void {			var ike:int;			var pIndex:int;			var randomNumber:Number;			var oldAlpha:Number;						if (_touched) {				return;			}						_touched = true;						if (myIndex < 0) {				myIndex = 0;			} else if (myIndex > colorTransforms.length - 1) {				myIndex = colorTransforms.length - 1;			}						for (ike = 0; ike < colorTransforms.length; ike += 1) {				_colorTransforms[ike] = colorTransforms[ike] = gleanCTData(colorTransforms[ike]);			}						if (colorizeChildren) {				setColorEvent.colorTransforms = colorTransforms;				for (ike = 0; ike < _colorChildren.length; ike += 1) {					if (_colorChildren[ike] is ColorSprite) {						setColorEvent.pIndex = _colorChildIndices[ike];						//_colorChildren[ike].dispatchEvent(setColorEvent);						_colorChildren[ike].setColors(colorTransforms, _colorChildIndices[ike]);					} else {												pIndex = _colorChildIndices[ike];												if (pIndex < 0) {							pIndex = 0;						} else if (pIndex > colorTransforms.length - 1) {							pIndex = colorTransforms.length - 1;						}												oldAlpha = _colorChildren[ike].alpha;						_colorChildren[ike].transform.colorTransform = colorTransforms[pIndex];						_colorChildren[ike].alpha = oldAlpha;					}				}			}						if (colorizeGuests) {				for (ike = 0; ike < _colorGuests.length; ike += 1) {					_colorGuests[ike].setColors(colorTransforms, _colorGuestIndices[ike]);				}			}						if (colorizeEnabled) {				transform.colorTransform = colorTransforms[myIndex];			}						_touched = false;		}						/**		*	Searches for a color child or color guest by using strict equality ( === )		*	and returns the color index of the item.		*			*	@param	searchElement	 The object of interest.		*	@param	trusted	 Determines whether to search for a color child or color guest.		*	@return		The color index of the item. If the item is not found, the return value is -1.		*/		public function colorOfChild(searchElement:Object, trusted:Boolean = true):int {						var returnVal:int = (trusted ? _colorChildren.indexOf(searchElement):_colorGuests.indexOf(searchElement));						if (returnVal != -1) {				returnVal = (trusted ? _colorChildIndices[returnVal] : _colorGuestIndices[returnVal]);			}						return returnVal;		}				// PRIVATE & PROTECTED METHODS				private function gleanCTData(obj:Object):ColorTransform {			var returnValue:ColorTransform;			if (obj is ColorTransform) {				return obj as ColorTransform;			} else if (obj is uint || obj is int) {				returnValue = new ColorTransform();				returnValue.color = obj as uint;				returnValue.redMultiplier = returnValue.redOffset / 0xFF;				returnValue.greenMultiplier = returnValue.greenOffset / 0xFF;				returnValue.blueMultiplier = returnValue.blueOffset / 0xFF;				returnValue.redOffset = returnValue.greenOffset = returnValue.blueOffset = 0;				return returnValue;			} else {				try {					returnValue = new ColorTransform(						obj.redMultiplier, 						obj.greenMultiplier, 						obj.blueMultiplier					);					return returnValue;				} catch (error:Error) {					throw new ArgumentError("Input object needs to have properties similar to ColorTransform.");				}			}			return PLAIN_CT;		}				private function setColorsFromEvent(event:ColorEvent):void {			setColors(event.colorTransforms, event.pIndex);		}	}}