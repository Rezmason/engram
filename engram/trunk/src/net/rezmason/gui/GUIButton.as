package net.rezmason.gui {		// IMPORT STATEMENTS	import flash.events.Event;	import flash.geom.Rectangle;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.text.TextFormat;	import flash.text.TextFormatAlign;	import flash.utils.getTimer;		public class GUIButton extends GUIAbstract {				// CLASS PROPERTIES		private static const BACK_OVERLAP:Number = 1;				// INSTANCE PROPERTIES		protected var _format:TextFormat;		protected var _txtLabel:TextField;		private var _backMiddle:GUIBasic, _backLeft:GUIBasic, _backRight:GUIBasic;		protected var dumbMeasurements:Object, customMeasurements:Object;		private var startTime:Number;		private var _waiting:Boolean = false;		private var _useMin:Boolean = true;				public function GUIButton():void {					var ike:int;						super(GUIAbstractEnforcer.INSTANCE);						expectedChildren["txtLabel"] = TextField;			expectedChildren["***BackMiddle"] = GUIBasic;			expectedChildren["***BackLeft"] = GUIBasic;			expectedChildren["***BackRight"] = GUIBasic;			verifyChildren(this);						buttonMode = true;			useHandCursor = true;			mouseChildren = false;						_txtLabel = getChildByName("txtLabel") as TextField;			_format = _txtLabel.getTextFormat();			_format.align ||= TextFormatAlign.CENTER;			_txtLabel.defaultTextFormat = _format;						_backMiddle = getChildByName("***BackMiddle") as GUIBasic;			addColorChild(_backMiddle);			_backLeft = getChildByName("***BackLeft") as GUIBasic;			addColorChild(_backLeft);			_backRight = getChildByName("***BackRight") as GUIBasic;			addColorChild(_backRight);						unifyButtons(this, true);						dumbMeasurements = {				leftOverlap: 0,				rightOverlap: 0,				leftOrigin: 0,				rightOrigin: 0,				width: 0,				minTextWidth: 0			};						if (stage) {				prime();			} else {				addEventListener(Event.ADDED_TO_STAGE, prime);			}			startTime = getTimer();					}				// GETTERS & SETTERS				public function get text():String {			return _txtLabel.text;		}				public function set text(str:String):void {			_txtLabel.text = str;			update();		}				public function set textAlign(str:String):void {			_format.align = str;			_txtLabel.defaultTextFormat = _format;			update();		}				public function get useMin():Boolean {			return _useMin;		}				public function set useMin(value:Boolean):void {			_useMin = value;			if (_useMin) {				_waiting = false;			}			update();		}				public function prime(event:Event = null):void {			if (!customMeasurements || !event) {				removeEventListener(Event.ADDED_TO_STAGE, prime);				customMeasurements = {					leftOverlap: _txtLabel.getBounds(this).left - _backLeft.getBounds(this).right,					rightOverlap: _txtLabel.getBounds(this).right - _backRight.getBounds(this).left,					leftOrigin: _backLeft.getBounds(this).right,					rightOrigin: _backRight.getBounds(this).left,					width: _backMiddle.width,					minTextWidth: _txtLabel.width				};				if (_waiting) {					_waiting = false;					update();				}			}		}				// PRIVATE & PROTECTED METHODS				protected function update():void {						var measurements:Object = (_useMin ? customMeasurements : dumbMeasurements);						if (!measurements) {				_waiting = true;				return;			}						_txtLabel.autoSize = TextFieldAutoSize.LEFT;			_txtLabel.text = _txtLabel.text;						if (_txtLabel.width < measurements.minTextWidth) {								with (measurements) {					_backLeft.x = leftOrigin;					_backMiddle.x = leftOrigin - BACK_OVERLAP;					_backMiddle.width = width + 2 * BACK_OVERLAP;					_backRight.x = rightOrigin;									_txtLabel.autoSize = TextFieldAutoSize.NONE;					_txtLabel.width = minTextWidth;					_txtLabel.x = leftOrigin + leftOverlap;									_txtLabel.defaultTextFormat = _format;					_txtLabel.text = _txtLabel.text;				}							} else {								_txtLabel.x = 0;								var bounds:Rectangle = _txtLabel.getBounds(this);				var shove:Number;								with (measurements) {					_backLeft.x = bounds.left - leftOverlap;					_backMiddle.x = bounds.left - leftOverlap - BACK_OVERLAP;					_backMiddle.width = bounds.width - leftOverlap - rightOverlap + 2 * BACK_OVERLAP;					_backRight.x = bounds.right - rightOverlap;				}								bounds = getBounds(this);								switch (_format.align) {					case TextFormatAlign.LEFT:						shove = -bounds.left;					//break;					case TextFormatAlign.RIGHT:						shove = -bounds.right;					//break;					default:						shove = (-bounds.left - bounds.right) / 2;					break;				}								_backLeft.x += shove;				_backMiddle.x += shove;				_backRight.x += shove;				_txtLabel.x += shove;			}		}	}}