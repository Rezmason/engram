package net.rezmason.gui {	import flash.display.BlendMode;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.ColorTransform;	import flash.geom.Rectangle;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.text.TextFormat;	import flash.text.TextFormatAlign;		import net.rezmason.display.ColorSprite;	public class AlertGuts extends ColorSprite {				// CLASS PROPERTIES		public static const DISAPPEAR:String = "disappear";				private static const DISAPPEAR_EVENT:Event = new Event(DISAPPEAR);		private static const WHITE_CT:ColorTransform = new ColorTransform(1, 1, 1, 1, 0xFF, 0xFF, 0xFF, 0xFF);		private static const PLAIN_CT:ColorTransform = new ColorTransform();				// INSTANCE PROPERTIES				protected var _margin:Number = 0, _topMargin:Number = 0;		protected var _symbolMargin:Number = 0, _symbolWidth:Number = 0;		protected var _textMargin:Number = 0;		protected var _buttonMargin:Number = 0, _buttonGap:Number = 0;		protected var _locked:Boolean = false;				private var _whiteText:Boolean = false;		private var _symbolContainer:Sprite = new Sprite;		private var _leftButtons:Array = [], _rightButtons:Array = [];		private var _leftFunctions:Array, _rightFunctions:Array;		private var leftButtonContainer:Sprite = new Sprite, rightButtonContainer:Sprite = new Sprite;		private var currentButton:GUIButton;		private var _defaultNo:GUIButton, _defaultYes:GUIButton;		private var _currentFunction:Function;		private var _maxWidth:Number;		private var _data:AlertData;		protected var _buttonClass:Class;				public function AlertGuts(__buttonClass:Class = null, maxW:Number = Infinity):void {						buttonClass = __buttonClass;						addChild(_symbolContainer);			addChild(leftButtonContainer);			addChild(rightButtonContainer);			rightButtonContainer.scaleX = -1;						txtTitle.autoSize = TextFieldAutoSize.LEFT;			txtBody.autoSize = TextFieldAutoSize.LEFT;			txtBody.wordWrap = true;						maxWidth = maxW;						//_symbolContainer.blendMode = BlendMode.DARKEN;		}				// GETTERS & SETTERS				public function get defaultYes():GUIButton {			return _defaultYes;		}				public function get defaultNo():GUIButton {			return _defaultNo;		}				public function get maxWidth():Number {			return _maxWidth;		}				public function set maxWidth(value:Number):void {			_maxWidth = Math.max(0, value);			update();		}				public function get buttonClass():Class {			return _buttonClass;		}				public function set buttonClass(value:Class):void {			if (value && new (value as Class) is GUIButton) {				_buttonClass = value;				_leftButtons = [];				_rightButtons = [];				update();			}		}				public function get symbol():DisplayObject {			return _symbolContainer.getChildAt(0);		}				public function set symbol(value:DisplayObject):void {						while (_symbolContainer.numChildren) {				_symbolContainer.removeChildAt(0);			}						_symbolContainer.addChild(value);						sizeSymbolContainer();		}				public function get whiteText():Boolean {			return _whiteText;		}				public function set whiteText(value:Boolean):void {						var format:TextFormat;						if (_whiteText != value) {				_whiteText = value;								format = txtTitle.defaultTextFormat;				format.color = (_whiteText ? 0xFFFFFF : 0x000000);				txtTitle.defaultTextFormat = format;								format = txtBody.defaultTextFormat;				format.color = (_whiteText ? 0xFFFFFF : 0x000000);				txtBody.defaultTextFormat = format;								//_symbolContainer.blendMode = (_whiteText ? BlendMode.NORMAL : BlendMode.DARKEN);				leftButtonContainer.transform.colorTransform = (_whiteText ? WHITE_CT : PLAIN_CT);				rightButtonContainer.transform.colorTransform = (_whiteText ? WHITE_CT : PLAIN_CT);			}		}				public function get margin():Number{			return _margin;		}				public function set margin(value:Number):void {			_margin = Math.max(0, value);			update();		}				public function get topMargin():Number{			return _topMargin;		}				public function set topMargin(value:Number):void {			_topMargin = Math.max(0, value);			update();		}				public function get symbolMargin():Number{			return _symbolMargin;		}				public function set symbolMargin(value:Number):void {			_symbolMargin = Math.max(0, value);			update();		}				public function get symbolWidth():Number{			return _symbolWidth;		}				public function set symbolWidth(value:Number):void {			_symbolWidth = Math.max(0, value);			sizeSymbolContainer();			update();		}				public function get textMargin():Number{			return _textMargin;		}				public function set textMargin(value:Number):void {			_textMargin = Math.max(0, value);			update();		}				public function get buttonMargin():Number{			return _buttonMargin;		}				public function set buttonMargin(value:Number):void {			_buttonMargin = Math.max(0, value);			update();		}				public function get buttonGap():Number{			return _buttonGap;		}				public function set buttonGap(value:Number):void {			_buttonGap = Math.max(0, value);			update();		}				// PUBLIC METHODS		public function show(data:AlertData):void {			_data = data;			update();		}				public function callFunction():void {			if (_currentFunction != null) {				_currentFunction();			}			_currentFunction = null;		}				public function lock():void {			_locked = true;		}				public function unlock():void {			_locked = false;		}				// PRIVATE & PROTECTED METHODS				protected final function update():void {						if (_data && _buttonClass && !_locked) {				updateGraphics();			}		}				protected function updateGraphics():void {						// redraw the text						txtTitle.wordWrap = false;						if (_data.title) {				txtTitle.text = _data.title;			} else {				txtTitle.text = "";			}						if (txtTitle.width + txtTitle.x + margin > _maxWidth) {				txtTitle.wordWrap = true;				txtTitle.width = _maxWidth - txtTitle.x - margin;			}						txtBody.width = txtTitle.width;			if (_data.body) {				txtBody.text = _data.body;			} else {				txtBody.text = "";			}						_symbolContainer.x = margin;			_symbolContainer.y = _topMargin + margin;						txtTitle.x = txtBody.x = _symbolContainer.x + _symbolWidth + _symbolMargin;			txtTitle.y = _topMargin + margin;			txtBody.y = txtTitle.y + txtTitle.height + _textMargin;						while (leftButtonContainer.numChildren) {				leftButtonContainer.removeChildAt(0);			}						while (rightButtonContainer.numChildren) {				rightButtonContainer.removeChildAt(0);			}						_leftFunctions = [];			_rightFunctions = [];						if (_data.leftButtons) {				makeButtons(_data.leftButtons, _leftButtons, _leftFunctions, leftButtonContainer, 1, TextFormatAlign.LEFT);			}						if (_data.rightButtons) {				makeButtons(_data.rightButtons, _rightButtons, _rightFunctions, rightButtonContainer, -1, TextFormatAlign.RIGHT);			}						while (leftButtonContainer.width + 2 * _buttonMargin > maxWidth) {				leftButtonContainer.removeChildAt(leftButtonContainer.numChildren - 1);			}						while (rightButtonContainer.width + 2 * _buttonMargin > maxWidth) {				rightButtonContainer.removeChildAt(rightButtonContainer.numChildren - 1);			}						while (leftButtonContainer.width + _buttonGap + rightButtonContainer.width + 2 * _buttonMargin > maxWidth) {				if (rightButtonContainer.numChildren > leftButtonContainer.numChildren) {					rightButtonContainer.removeChildAt(rightButtonContainer.numChildren - 1);				} else {					leftButtonContainer.removeChildAt(leftButtonContainer.numChildren - 1);				}			}						var rand:Number = Math.random();			var _width:Number = _maxWidth * rand + width * (1 - rand);						leftButtonContainer.x = margin;			rightButtonContainer.x = leftButtonContainer.x + leftButtonContainer.width + _buttonGap + margin;			rightButtonContainer.x = Math.max(_width - margin, rightButtonContainer.x);						txtTitle.width = width - txtTitle.x;			txtBody.width = width - txtBody.x;						rightButtonContainer.y = Math.max(_symbolContainer.y + _symbolWidth + _symbolMargin, txtBody.y + txtBody.height + _textMargin);			rightButtonContainer.y += margin;			leftButtonContainer.y = rightButtonContainer.y;		}				protected function makeButtons(source:Array, buttonList:Array, funcList:Array, dest:Sprite, flipVal:Number, align:String):void {			var spacing:Number = 0;			for (var ike:int = 0; ike < source.length; ike++) {				if (!buttonList[ike]) {					buttonList[ike] = new buttonClass();					buttonList[ike].addEventListener(MouseEvent.CLICK, clickResponder);				}				funcList[ike] = source[ike].func;				currentButton = buttonList[ike];				currentButton.scaleX = flipVal;				currentButton.text = source[ike].name;				if (currentButton.text == _data.defaultNo) {					_defaultNo = currentButton;				} else if (currentButton.text == _data.defaultYes) {					_defaultYes = currentButton;				}				currentButton.textAlign = align;				currentButton.x = spacing;				spacing += currentButton.width + _buttonMargin;				dest.addChild(currentButton);			}		}				protected function sizeSymbolContainer():void {						if (_symbolContainer.width > _symbolContainer.height) {				_symbolContainer.width = _symbolWidth;				_symbolContainer.scaleY = _symbolContainer.scaleX;			} else {				_symbolContainer.height = _symbolWidth;				_symbolContainer.scaleX = _symbolContainer.scaleY;			}						var rect:Rectangle = _symbolContainer.getBounds(_symbolContainer);						_symbolContainer.x += (_symbolWidth - _symbolContainer.width ) / 2 - rect.x;			_symbolContainer.y += (_symbolWidth - _symbolContainer.height) / 2 - rect.y;		}				protected final function clickResponder(event:MouseEvent):void {			var ike:int = 0;			var target:GUIButton = event.currentTarget as GUIButton;						if (_leftButtons.indexOf(target) !=  -1) {				_currentFunction = _leftFunctions[_leftButtons.indexOf(target)];			} else {				_currentFunction = _rightFunctions[_rightButtons.indexOf(target)];			}			_defaultNo = _defaultYes = null;			dispatchEvent(DISAPPEAR_EVENT);		}	}}