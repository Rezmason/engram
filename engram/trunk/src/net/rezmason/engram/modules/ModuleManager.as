package net.rezmason.engram.modules {		// IMPORT STATEMENTS	import flash.display.DisplayObject;	import flash.events.Event;	import flash.events.TimerEvent;	import flash.net.URLRequest;	import flash.system.ApplicationDomain;	import flash.system.LoaderContext;	import flash.utils.getDefinitionByName;	import flash.utils.Timer;		import net.rezmason.display.ColorSprite;	import net.rezmason.display.Grid;	import net.rezmason.engram.SettingsManager;	import net.rezmason.net.Syphon;	import net.rezmason.utils.isAIR;		public final class ModuleManager extends ColorSprite {				// CLASS PROPERTIES		private static const COMPLETE_EVENT:Event = new Event(Event.COMPLETE);		private static const _CONTEXT:LoaderContext = new LoaderContext();		private var _urls:Array, _files:Array;		private var File:Class;				// INSTANCE PROPERTIES		private var _goodLoaders:Object = {}, _goodFiles:Object = {}, _goodLoaderArray:Array = [];		private var _currentLoader:ModuleLoader, _debugLoader:ModuleLoader;		private var _builtIns:Array = [];		private var itr:int;		private var urlRequest:URLRequest = new URLRequest();		private var _grid:Grid;		private var _mainLoad:Boolean, _debugLoad:Boolean;		private var _inPlay:Boolean;		private var mainLoadCompleteTimer:Timer = new Timer(400, 1);		private var settingsManager:SettingsManager;		private var _container:ColorSprite;						public function ModuleManager(container:ColorSprite):void {						_container = container;						if (isAIR()) {				_CONTEXT.applicationDomain = new ApplicationDomain(null);			}						itr = 0;			settingsManager = SettingsManager.INSTANCE;			mainLoadCompleteTimer.addEventListener(TimerEvent.TIMER_COMPLETE, finishMainLoad, false, 0, true);		}				// GETTERS & SETTERS				public function get goodLoaders():Object {			var returnVal:Object = {};			for (var prop:String in _goodLoaders) {				returnVal[prop] = _goodLoaders[prop];			}			return returnVal;		}				public function get goodLoaderArray():Array {			return _goodLoaderArray.slice();		}				public function get grid():Grid {			return _grid;		}				public function set grid(value:Grid):void {			_grid = value;		}				public function beginMainLoad():void {			populateMainLists();			_mainLoad = true;			loadNext();		}				public function testCandidates(newList:Array, inPlay:Boolean = false, debug:Boolean = false):void {			var ike:int, jen:int;						_inPlay = inPlay;			_debugLoad = debug;						if (File) {				for (ike = 0; ike < newList.length; ike++) {					var item:Object = newList[ike];					if (item is File) {						_files.push(item);						_urls.push(item.url);					} else if (item.dir != null && item.args.length) {						for (jen = 0; jen < item.args.length; jen++) {							_files.push(item.dir.resolvePath(item.args[jen]));							_urls.push(_files[_files.length - 1].url);						}					}				}			}			loadNext();		}				public function packDebugModule():void {			var file:*			if (_debugLoader) {				trace("Pack Debug Module");				// Create an EGM file in the same directory as the debug file			}		}				public function rerez(ratio:Number):void {			for (var prop:String in _goodLoaders) {				_goodLoaders[prop].module.resize(ratio, _goodLoaders[prop].module.isPlaying);			}					}				public function interpretSettings(moduleTitle:String = ""):void {			if (moduleTitle.length && _goodLoaders[moduleTitle]) {				giveSettingsToModule(moduleTitle);			} else {								for (moduleTitle in _goodLoaders) {					giveSettingsToModule(moduleTitle);				}			}		}				public function jettisonAddedModules():void {			var fileListing:Array = [];			var file:*			var ike:int;			if (!File && isAIR()) {				File = getDefinitionByName("flash.filesystem.File") as Class;			}			if (File) {				file = File.applicationStorageDirectory.resolvePath("modules/");				if (file.exists) {					file.deleteDirectory(true);				}			}		}				public function loadersToNames(arr:Array):Array {			var returnVal:Array = new Array;			for (var ike:int = 0; ike < arr.length; ike++) {				if (arr[ike] is ModuleLoader) {					returnVal.push(arr[ike].module.title);				}			}			return returnVal;		}				public function namesToLoaders(arr:Array):Array {			var returnVal:Array = new Array;			for (var ike:int = 0; ike < arr.length; ike++) {				if (arr[ike] is String && goodLoaders[arr[ike]]) {					returnVal.push(goodLoaders[arr[ike]]);				}			}			return returnVal;		}				// PRIVATE & PROTECTED METHODS				private function giveSettingsToModule(moduleTitle:String):void {			var moduleSettings:Object = settingsManager.moduleSettings;			if (moduleSettings[moduleTitle]) {				_goodLoaders[moduleTitle].module.setSettings(moduleSettings[moduleTitle]);			} else {				moduleSettings[moduleTitle] = _goodLoaders[moduleTitle].module.getSettings();			}				_goodLoaders[moduleTitle].module.setGeneralOptions(settingsManager.options);		}				private function loadNext(event:Event = null):void {			if (event) {				// successfully loaded objects get pushed to the appropriate lists				if (event.type == ModuleLoaderEvent.DONE) {					// successfully loaded modules cannot share a name/title					if (_debugLoad) {						trace("Debug target loaded successfully.");					} else if (_goodLoaders[_currentLoader.module.title] == undefined) {						trace("Fresh module");						_goodLoaders[_currentLoader.module.title] = _currentLoader;						_goodLoaderArray.push(_currentLoader);						_container.addColorGuest(_currentLoader.module);						if (_mainLoad) {							grid.place(_currentLoader.moduleIcon);						}												if (_files[itr]) {							_goodFiles[_currentLoader.module.title] = _files[itr];							if (_files[itr].moveTo is Function) {								_files[itr].moveTo(makeStoredModuleLink(), true);							}						}					} else if (!_inPlay) {						var _incumbent:ModuleLoader = _goodLoaders[_currentLoader.module.title];						var _incumbentIndex:int = _goodLoaderArray.indexOf(_incumbent);						trace("Incumbent's file:", _goodFiles[_currentLoader.module.title]);						if (_builtIns.indexOf(_goodFiles[_currentLoader.module.title].url) != -1) {							trace("Someone's trying to overwrite a built-in module.");						} else if (_incumbent.module.version < _currentLoader.module.version) {							trace("Coup d'etat!");							_incumbent.discard();							_goodLoaders[_currentLoader.module.title] = _currentLoader;							_goodLoaderArray[_incumbentIndex] = _currentLoader;							_container.addColorGuest(_currentLoader.module);							if (_goodFiles[_currentLoader.module.title]) {								// delete the old file								_goodFiles[_currentLoader.module.title].deleteFile();							}							if (_files[itr]) {								_goodFiles[_currentLoader.module.title] = _files[itr];								// move in the new file								_files[itr].moveTo(makeStoredModuleLink(), true);							}						}					}				} else if (_mainLoad) {					grid.place(new (Syphon.getClass("FailIcon")) as DisplayObject);				} else if (_debugLoad) {					trace("Debug target failed to load.");				}								if (_debugLoad) {					_debugLoader = _currentLoader;					itr = _urls.length;				} else {					itr += 1;					}			}			trace(itr, _urls.length);			if (itr == _urls.length) {				if (_mainLoad) {					_mainLoad = false;					mainLoadCompleteTimer.start();				} else {					finishSupplementalLoad();				}			} else {				urlRequest.url = _urls[itr];				_currentLoader = new ModuleLoader;				_currentLoader.addEventListener(ModuleLoaderEvent.DONE, loadNext, false, -100, true);				_currentLoader.addEventListener(ModuleLoaderEvent.FAIL, loadNext, false, -100, true);				_currentLoader.loadOnce(urlRequest, _CONTEXT);			}		}				private function finishMainLoad(event:Event = null):void {			dispatchEvent(COMPLETE_EVENT);		}				private function finishSupplementalLoad(event:Event = null):void {			dispatchEvent(COMPLETE_EVENT);		}				private function populateMainLists():void {			var ike:int;			var addedModules:Array = findAddedModules();						_builtIns = BuiltInModules.GAME_LIST.slice();			_files = _builtIns.slice();			for (ike = 0; ike < _files.length; ike++) {				_files[ike] = {url:_files[ike]};			}			_files = _files.concat(addedModules);			for (ike = 0; ike < addedModules.length; ike++) {				addedModules[ike] = addedModules[ike].url;			}			_urls = _builtIns.concat(addedModules);			trace("URLs:", _urls);		}				private function findAddedModules():Array {			var returnVal:Array = [];			var file:*			var ike:int;						if (!File && isAIR()) {				File = getDefinitionByName("flash.filesystem.File") as Class;			}						if (File) {				file = File.applicationStorageDirectory.resolvePath("modules/");				if (!file.exists) {					file.createDirectory();				}				returnVal = file.getDirectoryListing();				for (ike = 0; ike < returnVal.length; ike += 1) {										if (returnVal[ike].isHidden) {						returnVal.splice(ike--, 1);						continue;					}				}			}			trace("Found", returnVal.length, "added modules.");			return returnVal;		}				private function makeStoredModuleLink():* {			var link:String;			var file:* = File.applicationStorageDirectory.resolvePath("modules/");						if (!file.exists) {				file.createDirectory();			}						while (file.exists) {				link = "modules/" + int(Math.random() * 1000000).toString() + "." + ModuleDefinition.MODULE_EXTENSION;				file = File.applicationStorageDirectory.resolvePath(link);			}			return file;		}	}	}