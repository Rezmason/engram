package net.rezmason.engram.modules {		// IMPORT STATEMENTS	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.TimerEvent;	import flash.net.URLRequest;	import flash.system.ApplicationDomain;	import flash.system.LoaderContext;	import flash.utils.getDefinitionByName;	import flash.utils.Timer;		import net.rezmason.display.ColorSprite;	import net.rezmason.engram.display.Startup;	import net.rezmason.engram.SettingsManager;	import net.rezmason.utils.isAIR;		public final class ModuleManager extends ColorSprite {				// CLASS PROPERTIES		private static const _INSTANCE:ModuleManager = new ModuleManager(SingletonEnforcer);		private static const COMPLETE_EVENT:Event = new Event(Event.COMPLETE);		private static const _CONTEXT:LoaderContext = new LoaderContext();		private static var _urls:Array;		private static var initialized:Boolean = false;		private static var File:Class;				// INSTANCE PROPERTIES		private var _goodLoaders:Object = {}, _goodLoaderArray:Array = [];		private var _currentLoader:ModuleLoader, _debugLoader:ModuleLoader;		private var itr:int;		private var urlRequest:URLRequest = new URLRequest();		private var startup:Startup;		private var mainLoadCompleteTimer:Timer = new Timer(400, 1);		private var settingsManager:SettingsManager;				// CONSTRUCTOR		public function ModuleManager(enf:Class):void {			if (enf != SingletonEnforcer) {				throw new ArgumentError("You do not create a ModuleManager; it is a Singleton.");			}						startup = Startup.INSTANCE;			settingsManager = SettingsManager.INSTANCE;						mainLoadCompleteTimer.addEventListener(TimerEvent.TIMER_COMPLETE, finishmainLoad, false, 0, true);		}				// STATIC GETTERS & SETTERS				public static function get INSTANCE():ModuleManager {			if (!initialized) {				if (isAIR()) {					_CONTEXT.applicationDomain = new ApplicationDomain(null);				}				populateMainLists();				initialized = true;			}			return _INSTANCE;		}				public function get goodLoaders():Object {			var returnVal:Object = {};			for (var prop:String in _goodLoaders) {				returnVal[prop] = _goodLoaders[prop];			}			return returnVal;		}				public function get goodLoaderArray():Array {			return _goodLoaderArray.slice();		}				// INTERNAL METHODS				public function beginMainLoad():void {			itr = 0;			loadNext();		}				public function adjustSizes(ratio:Number):void {			for (var prop:String in _goodLoaders) {				_goodLoaders[prop].module.resize(ratio, _goodLoaders[prop].module.isPlaying);			}					}				public function interpretSettings(moduleTitle:String = ""):void {			if (moduleTitle.length && _goodLoaders[moduleTitle]) {				giveSettingsToModule(moduleTitle);			} else {								for (moduleTitle in _goodLoaders) {					giveSettingsToModule(moduleTitle);				}			}		}				// PRIVATE METHODS				private function giveSettingsToModule(moduleTitle:String):void {			if (settingsManager.moduleSettings[moduleTitle]) {				_goodLoaders[moduleTitle].module.setSettings(settingsManager.moduleSettings[moduleTitle]);			} else {				settingsManager.moduleSettings[moduleTitle] = _goodLoaders[moduleTitle].module.getSettings();			}				_goodLoaders[moduleTitle].module.setGeneralOptions(settingsManager.options);		}				private function loadNext(event:Event = null):void {			if (event) {				// successfully loaded objects get pushed to the appropriate lists				if (event.type == ModuleLoaderEvent.DONE) {					// successfully loaded modules cannot share a name/title					if (_goodLoaders[_currentLoader.module.title] == undefined) {						_goodLoaders[_currentLoader.module.title] = _currentLoader;						_goodLoaderArray.push(_currentLoader);												addColorGuest(_currentLoader.module);												startup.place(_currentLoader.moduleIcon);					}				} else {					startup.place(new FailIcon());				}								itr += 1;			}						if (itr == _urls.length) {				mainLoadCompleteTimer.start();			} else {				urlRequest.url = _urls[itr];				_currentLoader = new ModuleLoader;				_currentLoader.addEventListener(ModuleLoaderEvent.DONE, loadNext, false, -100, true);				_currentLoader.addEventListener(ModuleLoaderEvent.FAIL, loadNext, false, -100, true);				_currentLoader.loadOnce(urlRequest, _CONTEXT);			}		}				private function finishmainLoad(event:Event):void {			dispatchEvent(COMPLETE_EVENT);		}				// PRIVATE STATIC METHODS				private static function populateMainLists():void {			var ike:int;			_urls = BuiltInModules.GAME_LIST.concat(findAddedModules());		}				private static function findAddedModules():Array {			var returnVal:Array = [];			var file;			var ike:int;						if (!File && isAIR()) {				File = getDefinitionByName("flash.filesystem.File") as Class;			}						if (File) {				file = File.applicationStorageDirectory.resolvePath("modules/");				if (!file.exists) {					file.createDirectory();				}				returnVal = file.getDirectoryListing();				for (ike = 0; ike < returnVal.length; ike += 1) {										if (returnVal[ike].isHidden) {						returnVal.splice(ike--, 1);						continue;					}					returnVal[ike] = returnVal[ike].url;				}			}						return returnVal;		}	}	}internal final class SingletonEnforcer{}