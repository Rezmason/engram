package net.rezmason.engram.modules {		// IMPORT STATEMENTS	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.Stage;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.geom.Matrix;	import flash.geom.Rectangle;	import flash.utils.ByteArray;		import net.rezmason.display.ColorSprite;	import net.rezmason.media.SoundManager;	public class Module extends ColorSprite {				// CLASS PROPERTIES		protected static const READY_EVENT:ModuleEvent = new ModuleEvent(ModuleEvent.MODULE_READY);		private static const PARENT_ERROR:SecurityError = new SecurityError("Modules can't access their parent objects. Nice try.");		private static const STAGE_ERROR:SecurityError = new SecurityError("Modules can't access their Stage objects.");				// INSTANCE PROPERTIES		public var isPlaying:Boolean = false, isPaused:Boolean = false;		protected var _settings:Object = {}, _defaultSettings:Object = {};		protected var _generalOptions:Object = {};		protected var _info:String, _version:String = "1.0";		protected var soundManager:SoundManager = SoundManager.INSTANCE;		protected var sounds:Object = {}, channels:Object = {};		protected var _title:String = "no_title";		protected var _view:View, _settingsView:View;		protected var _icon:DisplayObject;		protected var _gameType:String = GameType.DRILL;		protected var relay:EventDispatcher;				// CONSTRUCTOR		public function Module():void {			loaderInfo.addEventListener(Event.INIT, init, false, 0, true);			mouseEnabled = mouseChildren = false;		}				// GETTERS & SETTERS				override public function get parent():DisplayObjectContainer {			throw PARENT_ERROR;			return null;		}				override public function get stage():Stage {			throw STAGE_ERROR;			return null;		}				public function get version():String {			return _version;		}				public function get info():String {			return _info;		}				public function get title():String {			return _title;		}				public function get centerpiece():Object {			if (_view) {				return _view.centerpiece;			}			return null;		}				// these would be getters and setters, except setters don't work through the bridge(??), so they and		// their associated getters have been made into normal functions				public function getSettings():Object {			var returnValue:Object = {};			for (var prop:String in _settings) {				returnValue[prop] = _settings[prop];			}			return returnValue;		}				public function setSettings(value:Object):void {			for (var prop:String in value) {				_settings[prop] = value[prop];			}			interpretSettings();		}				public function setGeneralOptions(value:Object):void {			for (var prop:String in value) {				_generalOptions[prop] = value[prop];			}			interpretSettings();		}				// PUBLIC METHODS				public function resetSettings():void {			for (var prop:String in _defaultSettings) {				_settings[prop] = _defaultSettings[prop];			}		}				public function reset(event:Event = null):void {			if (_view) {				_view.reset();			}		}				public function resize(ratio:Number = 1, updateView:Boolean = false):void {					}				public function start(event:Event = null, gameType:String = null, debug:Boolean = false):void {			_gameType = gameType;			isPaused = false;			isPlaying = true;		}				public function pause(event:Event = null):void {			if (isPlaying) {				isPaused = true;			}		}				public function resume(event:Event = null):void {			if (isPlaying) {				isPaused = false;			}		}				public function end(event:Event = null):void {			isPaused = false;			isPlaying = false;		}				public function inputResponder(inputType:String, keyDown:Boolean = true):void {					}				public final function wipeDisplayList():void {			while (numChildren) {				removeChildAt(0);			}		}				public final function showGame():void {			wipeDisplayList();			addChild(_view);		}				public final function showSettings():void {			wipeDisplayList();			if (_settingsView) {				addChild(_settingsView);			}		}				public final function hasIcon():Boolean {			return (_icon != null);		}				public final function getIcon(resolution:int, returnData:Boolean = false):* {			var iconData:BitmapData = new BitmapData(resolution, resolution, true, 0x00000000);			var mat:Matrix = new Matrix;			var scaleVal:Number;			var rect:Rectangle;						if (_icon) {								rect = _icon.getBounds(_icon);				mat.translate(-rect.x, -rect.y);								scaleVal = resolution / Math.max(_icon.width, _icon.height);				mat.scale(scaleVal, scaleVal);								iconData.draw(_icon, mat, null, null, null, true);			}						if (returnData) {				return iconData.getPixels(iconData.rect);			}						return iconData.clone();		}				public function test():void {					}				public function unlock():void {			if (_view) {								wipeDisplayList();								addChild(_view);			}						soundManager.enlistSounds(sounds, channels);		}				public function moduleReady(event:Event = null):void {			dispatchEvent(READY_EVENT);			if (relay) {				relay.dispatchEvent(READY_EVENT);			}		}				// PRIVATE & PROTECTED METHODS				private function init(event:Event = null):void {						try {				loaderInfo["childSandboxBridge"] = this;				relay = loaderInfo.sharedEvents;			} catch(error:Error) {				// whatever			}						for (var prop:String in _defaultSettings) {				_settings[prop] = _defaultSettings[prop];			}		}				protected function set title(value:String):void {			if (value.length) {				_title = value;			}		}				protected function interpretSettings():void {					}	}}