package net.rezmason.engram {		import flash.display.Shape;	import flash.display.Sprite;	import flash.display.Stage;	import flash.events.Event;	import flash.geom.Point;	import flash.geom.Rectangle;		import gs.TweenLite;		import net.rezmason.display.ColorSprite;	import net.rezmason.gui.GUIButton;	import net.rezmason.display.Peeler;	internal class Prompt extends ColorSprite {				// CLASS PROPERTIES		private static const MARGIN:int = 50;		private static const ANGLE_RANGE:Number = 15;		internal static const DISAPPEAR:String = "disappear";				// INSTANCE PROPERTIES						private var alertBox:AlertGuts = new PromptGuts() as AlertGuts;		private var alertSurface:PromptSurface = new PromptSurface(500, 200);		private var _alertType:AlertType;		private var _palette:Array;				private var _stage:Stage;		private var peeler:Peeler;		private var sticker:Sprite = new Sprite;		private var stickerBack:Shape = new Shape;		private var sill1:Shape = new Shape, sill2:Shape = new Shape;		private var bounds:Rectangle;				private var timing:Number = 2;		private var tweenVars:Object = {};		private var peelOrigin:Point = new Point, peelOriginLocal:Point;				// CONSTRUCTOR		public function Prompt(stg:Stage):void {						_stage = stg;						sticker.addChild(alertSurface);			sticker.addChild(alertBox);			addColorChild(alertSurface);			addColorChild(alertBox);						addChild(sticker);						peeler = new Peeler(sticker, stickerBack, sill1, sill2);			peeler.shiny = false;			addChild(peeler);						peeler.axisX = sticker.width;			peeler.axisY = sticker.height;			peeler.axisR = 0;						alertType = AlertType.DECISION;	//AlertType.DECISION;						alertBox.addEventListener(DISAPPEAR, disappear);						mouseEnabled = mouseChildren = false;		}				// GETTERS & SETTERS				public function get defaultAffirmative():GUIButton {			return alertBox.defaultAffirmative;		}				public function get defaultNegative():GUIButton {			return alertBox.defaultNegative;		}				internal function get alertType():AlertType {			return _alertType;		}				internal function set alertType(value:AlertType):void {			_alertType = value;			alertBox.symbol = _alertType.symbol;			_palette = GamePalette.ALERT_PALETTES[alertType.paletteIndex].slice();			alertBox.whiteText = !isBright(_palette[0]);			setColors(_palette);			alertSurface.textureAlpha = _alertType.textureAlpha;		}				// INTERNAL METHODS				internal function show(title:String = "", messsage:String = "", leftButtons:Array = null, rightButtons:Array = null, 							   defaultAffirmative:String = null, defaultNegative:String = null, prox:Point = null):void {			alertBox.show(title, messsage, leftButtons, rightButtons, defaultAffirmative, defaultNegative);			alertBox.setColors(_palette);			alertSurface.redraw(alertBox.width + 2 * AlertGuts.MARGIN, alertBox.height + 2 * AlertGuts.MARGIN + AlertGuts.TOP_MARGIN);						peeler.x = 0;			peeler.y = 0;						peeler.rotation = (Math.random() * 2 - 1) * ANGLE_RANGE;			bounds = sticker.getBounds(this);						if (prox) {				peeler.x = prox.x - bounds.x - bounds.width  / 2;				peeler.x = Math.min(peeler.x, _stage.stageWidth  - MARGIN * 2 - bounds.width  - bounds.x + MARGIN);				peeler.x = Math.max(peeler.x, -bounds.x + MARGIN);								peeler.y = prox.y - bounds.y - bounds.height / 2;				peeler.y = Math.min(peeler.y, _stage.stageHeight - MARGIN * 2 - bounds.height - bounds.y + MARGIN);				peeler.y = Math.max(peeler.y, -bounds.y + MARGIN);			} else {				peeler.x = Math.random() * (_stage.stageWidth  - MARGIN * 2 - bounds.width ) - bounds.x + MARGIN;				peeler.y = Math.random() * (_stage.stageHeight - MARGIN * 2 - bounds.height) - bounds.y + MARGIN;				}						alertSurface.makeStickerBack(stickerBack);			alertSurface.makeSillhouette(sill1);			alertSurface.makeSillhouette(sill2);						peeler.update();						appear();		}				internal function resize(w:int, h:int):void {			alertSurface.redraw(w, h);		}				internal function rerez(ratio:Number = 1):void {			alertSurface.rerez(ratio);		}				// PRIVATE METHODS				private function isBright(color:uint):Boolean {			return ((color >> 16) & 0xFF) + ((color >> 8) & 0xFF) + (color & 0xFF) > 0xE0;		}				private function appear(event:Event = null):void {			TweenLite.killTweensOf(peeler);						if (Math.random() > 0.5) {				peelOrigin.x = (Math.random() > 0.5 ? -bounds.width  : _stage.stageWidth ) - bounds.x;				peelOrigin.y = Math.random() * (_stage.stageHeight - bounds.height) - bounds.y;			} else {				peelOrigin.x = (Math.random() > 0.5 ? -bounds.height : _stage.stageHeight) - bounds.y;				peelOrigin.y = Math.random() * (_stage.stageWidth  - bounds.width ) - bounds.x;			}						peelOriginLocal = peeler.globalToLocal(localToGlobal(peelOrigin));						peeler.axisX = peelOriginLocal.x;			peeler.axisY = peelOriginLocal.y;			peeler.axisR = 0;						peelOrigin.x = _stage.stageWidth - peelOrigin.x;			peelOrigin.y = _stage.stageWidth - peelOrigin.y;						peelOriginLocal = peeler.globalToLocal(localToGlobal(peelOrigin));						tweenVars.axisX = peelOriginLocal.x;			tweenVars.axisY = peelOriginLocal.y;			tweenVars.axisR = 0;			tweenVars.onComplete = enableClicks;						TweenLite.from(peeler, timing, tweenVars);		}				private function disappear(event:Event = null):void {						mouseEnabled = mouseChildren = false;						TweenLite.killTweensOf(peeler);			trace("disappear");						peeler.axisX = 0;			peeler.axisY = 0;			peeler.axisR = 0;			tweenVars.axisX = 0;			tweenVars.axisY = 0;			tweenVars.axisR = 0;						TweenLite.to(peeler, timing, tweenVars);		}				private function enableClicks():void {			mouseEnabled = mouseChildren = true;		}	}}