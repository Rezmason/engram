package net.rezmason.engram.menus {		// IMPORT STATEMENTS	import flash.display.InteractiveObject;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.text.TextFormatAlign;	import flash.ui.Keyboard;		import net.rezmason.display.Moment;	import net.rezmason.engram.Main;	import net.rezmason.engram.SettingsManager;	import net.rezmason.engram.modules.ModuleKeyRoles;	import net.rezmason.gui.GUIButton;	import net.rezmason.gui.GUIBtnKey;	import net.rezmason.gui.GUICheckBox;	import net.rezmason.media.SoundManager;	import net.rezmason.utils.keyboardEventToString;		public class SettingsMenu extends MenuBase {				// INSTANCE PROPERTIES		private var listeningState:int = 0;		private var options:Object;		private var keyRef:Object;		private var usedKeys:Object;		private var currentGUIBtnKey:GUIBtnKey, currentCheckBox:GUICheckBox, currentFlag:Moment;		private var inputObject:InteractiveObject;		private var settingsManager:SettingsManager = SettingsManager.INSTANCE;		private var soundManager:SoundManager = SoundManager.INSTANCE;		private var _main:Main;				// CONSTRUCTOR		public function SettingsMenu(__main:Main):void {						_main = __main;						addColorChild(btnAKey);			addColorChild(btnBKey);			addColorChild(btnXKey);			addColorChild(btnLKey);			addColorChild(btnRKey);			addColorChild(btnUKey);			addColorChild(btnDKey);						addColorChild(btnDefaults);			addColorChild(btnReturn);			addColorChild(chxEffects);			addColorChild(chxColors);			addColorChild(chxAudio);			addColorChild(chxSmoothing);						btnDefaults.textAlign = TextFormatAlign.CENTER;						chxEffects.addEventListener(MouseEvent.CLICK, chxResponder);			chxColors.addEventListener(MouseEvent.CLICK, chxResponder);			chxAudio.addEventListener(MouseEvent.CLICK, chxResponder);			chxSmoothing.addEventListener(MouseEvent.CLICK, chxResponder);						btnAKey.role = ModuleKeyRoles.AKEY;			btnBKey.role = ModuleKeyRoles.BKEY;			btnXKey.role = ModuleKeyRoles.XKEY;			btnLKey.role = ModuleKeyRoles.LKEY;			btnRKey.role = ModuleKeyRoles.RKEY;			btnUKey.role = ModuleKeyRoles.UKEY;			btnDKey.role = ModuleKeyRoles.DKEY;						btnAKey.flag = btnAFlag;			btnBKey.flag = btnBFlag;			btnXKey.flag = btnXFlag;			btnLKey.flag = btnLFlag;			btnRKey.flag = btnRFlag;			btnUKey.flag = btnUFlag;			btnDKey.flag = btnDFlag;						btnAKey.addEventListener(MouseEvent.CLICK, setKey);			btnBKey.addEventListener(MouseEvent.CLICK, setKey);			btnXKey.addEventListener(MouseEvent.CLICK, setKey);			btnLKey.addEventListener(MouseEvent.CLICK, setKey);			btnRKey.addEventListener(MouseEvent.CLICK, setKey);			btnUKey.addEventListener(MouseEvent.CLICK, setKey);			btnDKey.addEventListener(MouseEvent.CLICK, setKey);						btnDefaults.addEventListener(MouseEvent.CLICK, defaults);			btnReturn.addEventListener(MouseEvent.CLICK, revertKey);			btnReturn.addEventListener(MouseEvent.CLICK, applySettings);						btnReturn.addEventListener(MouseEvent.CLICK, _main.interpretSettings);			btnReturn.addEventListener(MouseEvent.CLICK, _main.showLast);						_defaultYes = null;			_defaultNo = btnReturn;						init(_main.stage);		}				// GETTERS & SETTERS				public function get listening():Boolean {			return (listeningState != 0);		}				// PUBLIC METHODS				public function showModuleSlide():void {					}				// PRIVATE METHODS				private function init(io:InteractiveObject):void {						keyRef = {};			var keyMeanings:Object = settingsManager.keyMeanings;			for (var prop in keyMeanings) {				keyRef[keyMeanings[prop]] = prop;			}						options = settingsManager.options;			refreshKeys();			refreshCheckBoxes();						inputObject = io;			inputObject.addEventListener(KeyboardEvent.KEY_DOWN, keyResponder);			inputObject.addEventListener(KeyboardEvent.KEY_UP, resetListening);		}				private function applySettings(event:Event = null):void {						var keyMeanings:Object = {};			for (var prop in keyRef) {				keyMeanings[keyRef[prop]] = prop;			}			settingsManager.keyMeanings = keyMeanings;						settingsManager.options = options;		}				private function setKey(event:MouseEvent):void {						revertKey();						stage.focus = inputObject; // just being sure			currentGUIBtnKey = event.currentTarget as GUIBtnKey;			usedKeys[keyRef[currentGUIBtnKey.role]] = undefined;			currentGUIBtnKey.pending = true;			listeningState = 2;		}				private function revertKey(event:Event = null):void {			if (listeningState == 2) {				currentGUIBtnKey.pending = false;				usedKeys[keyRef[currentGUIBtnKey.role]] = currentGUIBtnKey.role;			}		}				private function refreshCheckBoxes():void {			chxEffects.state    = options.blnEffects;			chxColors.state     = options.blnColors;			chxAudio.state      = options.blnAudio;			chxSmoothing.state  = options.blnSmoothing;		}				private function refreshKeys():void {						btnAKey.char = keyRef[ModuleKeyRoles.AKEY];			btnBKey.char = keyRef[ModuleKeyRoles.BKEY];			btnXKey.char = keyRef[ModuleKeyRoles.XKEY];			btnLKey.char = keyRef[ModuleKeyRoles.LKEY];			btnRKey.char = keyRef[ModuleKeyRoles.RKEY];			btnUKey.char = keyRef[ModuleKeyRoles.UKEY];			btnDKey.char = keyRef[ModuleKeyRoles.DKEY];						usedKeys = {};			usedKeys[keyRef[ModuleKeyRoles.AKEY]] = btnAKey;			usedKeys[keyRef[ModuleKeyRoles.BKEY]] = btnBKey;			usedKeys[keyRef[ModuleKeyRoles.XKEY]] = btnXKey;			usedKeys[keyRef[ModuleKeyRoles.LKEY]] = btnLKey;			usedKeys[keyRef[ModuleKeyRoles.RKEY]] = btnRKey;			usedKeys[keyRef[ModuleKeyRoles.UKEY]] = btnUKey;			usedKeys[keyRef[ModuleKeyRoles.DKEY]] = btnDKey;		}				private function defaults(event:Event = null):void {			revertKey();						settingsManager.defaults();						keyRef = {};			var keyMeanings:Object = settingsManager.keyMeanings;			for (var prop in keyMeanings) {				keyRef[keyMeanings[prop]] = prop;			}						options = settingsManager.options;						refreshKeys();			refreshCheckBoxes();		}		private function keyResponder(event:KeyboardEvent = null, oldValue:String = null):void {			if (listeningState == 2) {				var keyName:String;								keyName = keyboardEventToString(event);								if (!keyName || keyName == "TAB" || keyName == "ENTER") {					return;				}								if (currentFlag) {					currentFlag.stop();				}								if (keyName == "ESCAPE" || keyName == "`") {					revertKey();				} else if (usedKeys[keyName]) {					currentFlag = usedKeys[keyName].flag;					currentFlag.play();					soundManager.play("mispressSound");					_main.zap();				} else {						soundManager.play("entrySound");					usedKeys[keyRef[currentGUIBtnKey.role]] = undefined;					usedKeys[keyName] = currentGUIBtnKey;					keyRef[currentGUIBtnKey.role] = keyName;					currentGUIBtnKey.char = keyName;					currentGUIBtnKey = null;					listeningState = 1;					stage.focus = stage;				}			}		}				private function resetListening(event:KeyboardEvent = null):void {			if (listeningState == 1) {				listeningState = 0;			}		}				private function chxResponder(event:MouseEvent):void {			currentCheckBox = event.currentTarget as LargeCheckBox;			switch (currentCheckBox) {				case chxColors:					options.blnColors = currentCheckBox.state;				break;				case chxEffects:					options.blnEffects = currentCheckBox.state;				break;				case chxAudio:					options.blnAudio = currentCheckBox.state;				break;				case chxSmoothing:					options.blnSmoothing = currentCheckBox.state;				break;			}		}	}}