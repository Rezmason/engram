package net.rezmason.engram.games.busybodhi {	// IMPORT STATEMENTS	import flash.events.EventDispatcher;	internal class Track extends EventDispatcher {				// CLASS PROPERTIES		internal static const MAX_ALTITUDE:int = 12, MAX_SPEED:int = 100;		private static const MIN_COMBO_SIZE:int = 2, MAX_COMBO_SIZE:int = 8;		private static const TILE_ADDED_EVENT:BBEvent = new BBEvent(BBEvent.TILE_ADDED);		private static const TILE_CLEARED_EVENT:BBEvent = new BBEvent(BBEvent.TILE_CLEARED);				// INSTANCE PROPERTIES		private var tree:ComboNode = ComboNode.plantTree();		private var nodeComboPool:Object = {};		private var tiles:Array = [], tilesByName:Object = {}, numTiles:int = 0;		private var primaryTile:Tile, currentTile:Tile;		private var _speed:int = 10;		private var _difficultyLevel:int = 2;		private var _stackable:Boolean;		private var _full:Boolean;		private var comboSizeCap:int = MIN_COMBO_SIZE;		private var contents:int = 0;				public function Track(stackable:Boolean = true) {			_stackable = stackable;		}				internal function addTile():String {			var combo:String = addCombo(goodLength());			if (combo) {				primaryTile = new Tile();				primaryTile.altitude = MAX_ALTITUDE;				primaryTile.size = combo.length;				primaryTile.combo = combo;				tiles.push(primaryTile);				tilesByName[combo] = primaryTile;				contents += combo.length;				numTiles++;			}			TILE_ADDED_EVENT.combo = combo;			dispatchEvent(TILE_ADDED_EVENT);			return combo;		}				internal function removeTile(combo:String, cleared:Boolean = false, comboSpeed:int = 0):Boolean {			var success:Boolean = removeCombo(combo);			if (success) {				var tile:Tile = tilesByName[combo];				tiles.splice(tiles.indexOf(tile), 1);				tilesByName[combo] = undefined;				contents -= combo.length;				numTiles--;				if (cleared) {					_difficultyLevel; // adjust difficulty					_speed; // adjust falling speed					TILE_CLEARED_EVENT.combo = combo;					dispatchEvent(TILE_CLEARED_EVENT);				}			}			return success;		}				internal function get difficultyLevel():int {			return _difficultyLevel;		}				private function addCombo(length:int):String {			var node:ComboNode = tree.add(length);			if (node) {				nodeComboPool[node.combo] = node;				return node.combo;			}			return null;		}				internal function find(combo:String, complete:Boolean = false):Array {			return tree.find(combo, complete);		}				private function removeCombo(combo:String):Boolean {			if (nodeComboPool[combo]) {				if (nodeComboPool[combo].removeAndCollapse()) {					nodeComboPool[combo] = undefined;					return true;				}			}			return false;		}				internal function clear():void {			tree.clear();		}				internal function get settled():Boolean {			if (primaryTile) {				return false;			}			return true;		}				internal function get full():Boolean {			return _full;		}				internal function get speed():int {			return _speed;		}				internal function updateTiles():Array {			var stackHeight:Number = 0;			var slippedTiles:Array = [];			for (var ike:int = 0; ike < tiles.length; ike++) {				var tile:Tile = tiles[ike];				if (_stackable && tile.altitude - _speed / MAX_SPEED <= stackHeight) {					tile.altitude = stackHeight;					stackHeight += tile.size;					if (tile == primaryTile) {						primaryTile = null;					}				} else {					tile.altitude -= _speed / MAX_SPEED;					if (-tile.altitude > tile.size) {						slippedTiles.push(tile.combo);					}				}			}			if (stackHeight >= MAX_ALTITUDE) {				_full = true;			}			return slippedTiles;		}				internal function spew():void {			var spew:Array = tree.allLeaves();			trace("leaves:");			for (var ike:int = 0; ike < spew.length; ike++) {				trace(ike + ":(" + spew[ike].combo + ")");			}		}				private function goodLength():int {			var max:int = Math.min(comboSizeCap, MAX_ALTITUDE - contents) - MIN_COMBO_SIZE;			return MIN_COMBO_SIZE + int(Math.random() * max);		}	}}internal class ComboNode {		// CLASS PROPERTIES	private static var unusedNodes:Array = [];		// INSTANCE PROPERTIES		internal var index:String = "";	internal var combo:String = "";	internal var parentNode:ComboNode;	internal var rootNode:ComboNode;	internal var a:ComboNode, b:ComboNode, x:ComboNode, y:ComboNode;	internal var numChildren:int = 0;	internal var availableSlots:Array = [];		private var kid:ComboNode, kidNames:Array = ["a", "b", "x", "y"];	private var ike:int;		internal function clear():void {		if (numChildren) {			for (ike = 0; ike < 4; ike++) {				kid = this[kidNames[ike]] as ComboNode;				if (kid != null) {					kid.clear();					this[kidNames[ike]] = null;				}			}		}		index = "";		combo = "";		numChildren = 0;		availableSlots[0] = 0;		if (rootNode != this) {			parentNode = null;			rootNode = null;			unusedNodes.push(this);		}	}		internal function find(address:String, complete:Boolean = false):Array {		if (address.length) {			kid = this[address.charAt(0)];			if (kid != null) {				return kid.find(address.substr(1), complete);			}			return [];		}				if (complete) {			return numChildren ? [] : [combo];		}				return allLeaves();	}		internal function allLeaves():Array {		var returnVal:Array = [];		if (numChildren) {			for (ike = 0; ike < 4; ike++) {				kid = this[kidNames[ike]] as ComboNode;				if (kid != null) {					returnVal.push.apply(null, kid.allLeaves());				}			}		} else if (this != rootNode) {			returnVal = [this];		}		return returnVal;	}		internal function removeAndCollapse():Boolean {		if (numChildren) {			return false;		}		if (rootNode != this) {			parentNode[index] = null;			if (!--parentNode.numChildren) {				parentNode.removeAndCollapse();			}			parentNode = null;			rootNode = null;			unusedNodes.push(this);		}		return true;	}		internal function add(level:int):ComboNode {		// if the level is zero,		if (level == 0) {			// this is the new leaf			return this;		}		// otherwise,		var probs:Array = [0, 0, 0, 0];		var total:int = 0;		// weight the four child nodes		for (ike = 0; ike < 4; ike++) {			kid = this[kidNames[ike]] as ComboNode;			if (kid != null) {				// weight = number of empty slots under node of depth level - 1				if (kid.availableSlots[level - 1] == undefined) {					kid.availableSlots[level - 1] = Math.pow(4, level - 1);				}				probs[ike] = kid.availableSlots[level - 1];			} else {				probs[ike] = Math.pow(4, level - 1);			}			total += probs[ike];		}		// pick a node randomly		var rand:Number = Math.random() * total;		for (ike = 0; ike < 4; ike++) {			if (rand < probs[ike]) {				kid = this[kidNames[ike]];				break;			}			rand -= probs[ike];		}		//Assert: if you didn't pick any of the four,		if (ike == 4) {			// you are full and you are the root node OR there is an error			return null;		}		// if the chosen node doesn't exist,		if (kid == null) {			// make a new child node			kid = this[kidNames[ike]] = makeNode(this);			numChildren++;			kid.index = kidNames[ike];			kid.combo = combo + kid.index;			var node:ComboNode = this, nodeIndex:int = 1;			while (node != rootNode) {				if (node.availableSlots[nodeIndex] == undefined) {					node.availableSlots[nodeIndex] = Math.pow(4, nodeIndex);				}				node.availableSlots[nodeIndex]--;				nodeIndex++;				node = node.parentNode;			}		}				// chosen node . add(level - 1)				return kid.add(level - 1);	}		internal static function plantTree():ComboNode {		return makeNode(null);	}		internal static function makeNode(parentNode:ComboNode = null):ComboNode {		var node:ComboNode = (unusedNodes.length ? unusedNodes.shift() : (new ComboNode()));		node.parentNode = parentNode || node;		node.rootNode = node.parentNode.rootNode || node;		node.availableSlots = [0];		return node;	}		public function toString():String {		return "leaf " + combo;	}}internal class Tile {		// INSTANCE PROPERTIES	internal var altitude:Number = 0;	internal var size:Number = 1;	internal var combo:String = "";}