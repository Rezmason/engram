package net.rezmason.engram.games.busybodhi {		// IMPORT STATEMENTS	import flash.display.*;	import flash.events.*;	import flash.geom.*;		import net.rezmason.engram.modules.Game;	import net.rezmason.utils.Hat;		internal final class BBGame extends Game {				// CLASS PROPERTIES		internal static const MAX_TRACKS:int = 5;		internal static const MAX_ALTITUDE:int = Track.MAX_ALTITUDE;				// INSTANCE PROPERTIES				private static const MAX_ROUND_SCORE:int = 2000;		private static const PEAK_SPEED:int = 100;		private var _comboString:String, comboTime:int;		private var tracks:Array, crazyTrack:Track = new Track(false);		private var _panic:Number, _craziness:Number;		private var _pointer:int, _continuousPointer:Number;		private var _continuous:Boolean;		private var _score:int, _roundScore:int;		private var _numTracks:int;				// PUBLIC METHODS				override public function reset(event:Event = null):void {			_comboString = "";			comboTime = 0;			tracks = [];			_numTracks = 0;			crazyTrack.clear();			_panic = 0;			_craziness = 0;			_pointer = 0;			_continuousPointer = 0;			_continuous = false;			_score = 0;			_roundScore = 0;		}				internal function resetRoundScore():void {			_roundScore = 0;		}				internal function get score():int {			return _score;		}				override public function gameOver():void {			crazyTrack.clear();			tracks[0].clear();			super.gameOver();		}				internal function get maxAltitude():int {			return Track.MAX_ALTITUDE;		}				public function debug():void {					}				// INTERNAL METHODS				internal function initialize():void {			trace("M", "Initialize game");			addTrack();/*						addTrack();			addTrack();			for (var ike:int = 0; ike < 3; ike++) {				addTileToTrack(null, 0, 3);				addTileToTrack(null, 1, 3);				addTileToTrack(null, 2, 3);			}			tracks[0].spew();			*/			resetRoundScore();		}				internal function addTrack():int {			var returnVal:int;			for (var ike:int = 0; ike < _numTracks + 1; ike++) {				if (!tracks[ike]) {					returnVal = ike;					break;				}			}			var track:Track = new Track();			track.addEventListener(TimerEvent.TIMER_COMPLETE, addTileToTrack, false, 0, true);			tracks[returnVal] = track;			_numTracks++;			BBEvent.yell(this, BBEvent.TRACK_ADDED, {index:returnVal});			return returnVal;		}				internal function removeTrack(trackIndex):void {			tracks[trackIndex].clear();			tracks.splice(trackIndex, 1);			if (_pointer == trackIndex && _pointer != 0) {				_pointer--;			}			_numTracks--;			BBEvent.yell(this, BBEvent.TRACK_REMOVED, {index:trackIndex});		}				private function addTileToTrack(event:Event = null, trackIndex:int = 0, tileLength:int = 0):void {			var track:Track;			if (event) {				track = event.target as Track;				trackIndex = tracks.indexOf(track); // -1 if it's crazyTrack, right? :D			} else if (trackIndex > -1 && tracks[trackIndex]) {				track = tracks[trackIndex];			} else {				track = crazyTrack;				trackIndex = -1;			}						var tile:Tile = track.addTile(null, tileLength);			BBEvent.yell(this, BBEvent.TILE_ADDED, {				index:trackIndex,				address:tile.address, 				altitude:tile.altitude, 				shift:tile.shift			});		}				internal function bump(direction:Number = 1):void {			if (_continuous) {				_continuousPointer += direction;				if (_continuousPointer > _numTracks - 1 + 0.5) {					_continuousPointer = _numTracks - 1 + 0.5;				}				if (_continuousPointer < 0.5) {					_continuousPointer = 0.5;				}			} else {				tracks[_pointer].fall();				_pointer += direction;				if (_pointer > _numTracks - 1) {					_pointer = _numTracks - 1;				}				if (_pointer < 0) {					_pointer = 0;				}			}						updateMatches(_comboString);		}				internal function get speed():int {			var averageSpeed:int = 0;			for (var ike:int = 0; ike < _numTracks; ike++) {				averageSpeed += tracks[ike].speed;			}			return averageSpeed / _numTracks;;		}				internal function get continuous():Boolean {			return _continuous;		}				internal function set continuous(value:Boolean):void {			if (!_continuous && value) {				_continuousPointer = 0.5 + _pointer / (_numTracks - 1);			}			_continuous = value;		}				internal function get pointer():Number {			if (_continuous) {				return _continuousPointer;			}			return _pointer;		}				internal function get numTracks():int {			return _numTracks;		}				internal function updateTracks():void {			for (var ike:int = 0; ike < _numTracks; ike++) {				var currentTrack:Track = tracks[ike];								currentTrack.updateTiles();				broadcastPositions(ike);								if (currentTrack.tilesTouched) {					if (currentTrack.settled) {						BBEvent.yell(this, BBEvent.TRACK_SETTLED, {index:ike});						currentTrack.addTileSoon();					} else {						BBEvent.yell(this, BBEvent.TILES_TOUCHED, {index:ike});					}				}								_panic; // adjust the panic level								if (currentTrack.full) {					if (_numTracks > 1) {						removeTrack(ike);					} else {						gameOver();					}				}			}						var slippedTiles:Array = crazyTrack.updateTiles();			broadcastPositions(-1);			for (ike = 0; ike < slippedTiles.length; ike++) {				BBEvent.yell(this, BBEvent.TILE_GONE, {index:-1, address:slippedTiles[ike]});				_craziness; // adjust craziness			}		}				private function broadcastPositions(trackIndex:int):void {			var track:Track = (trackIndex == -1 ? crazyTrack : tracks[trackIndex]);			var tiles:Array = track.tiles;						for (var ike:int = 0; ike < tiles.length; ike++) {				var tile:Tile = tiles[ike];				BBEvent.yell(this, BBEvent.TILE_MOVED, {index:trackIndex, shift:tile.shift, altitude:tile.altitude, address:tile.address});			}		}				internal function pushCombo(beat:Beat):void {			if (_comboString.length) {				comboTime += beat.time;			}			_comboString += beat.key;			BBEvent.yell(this, BBEvent.UPDATE_COMBO, {address:_comboString});			updateMatches(beat.key);		}				internal function cancelCombo(event:Event = null):void {			BBEvent.yell(this, BBEvent.CLEAR_COMBO, {address:_comboString});			_comboString = "";			comboTime = 0;			clearMatches();			//trace("M", "--no combo--");		}				private function clearMatches():void {			for (var ike:int = 0; ike < _numTracks; ike++) {				tracks[ike].fall();			}			crazyTrack.fall();		}				private function updateMatches(pattern:String):void {			var crazyMatch:Boolean = false, match:Boolean = false;			var track:Track;						//trace("M", _comboString);			// tell the tracks to climb their trees to the appropriate node			if (pattern.length == 1) {				crazyMatch = crazyTrack.climb(pattern);			}						if (!_continuous) {				track = tracks[_pointer];				match = track.climb(pattern);			}						if (crazyMatch && crazyTrack.foundMatch()) {				// clear a crazy tile				BBEvent.yell(this, BBEvent.TILE_CLEARED, {index:-1, address:crazyTrack.currentAddress});				crazyTrack.removeTile(crazyTrack.currentAddress, comboTime);				//trace("M", "~~~");				// adjust craziness				_craziness;				adjustScore();				cancelCombo();			} else if (match && track.foundMatch()) {				// clear a tile from the current track				BBEvent.yell(this, BBEvent.TILE_CLEARED, {index:_pointer, address:track.currentAddress});				track.removeTile(track.currentAddress, comboTime);				//trace("M", "!!!");				adjustScore();				cancelCombo();			} else if (!crazyMatch && !match){				//trace("M", "___");				// clear the current combo				cancelCombo();			} else {				// light up potential tiles				if (crazyMatch) {					lightTiles(-1, crazyTrack.partialMatches, _comboString.length);				}				if (match) {					lightTiles(_pointer, track.partialMatches, _comboString.length);				}			}		}				private function lightTiles(trackIndex:int, addresses:Array, length:int):void {			for (var ike:int = 0; ike < addresses.length; ike++) {				BBEvent.yell(this, BBEvent.TILE_LIT, {					index:trackIndex, 					address:addresses[ike],					length:length				});			}		}				private function adjustScore():void {			_score; // add points to score			if (_score - _roundScore > MAX_ROUND_SCORE) {				// switch out			}			if (speed > PEAK_SPEED) {				decideEnding();			}		}				internal function decideEnding():void {			// decide on an ending			BBEvent.yell(this, BBEvent.TURNING_POINT, {ending:BBEnding.LOOPY});		}	}}