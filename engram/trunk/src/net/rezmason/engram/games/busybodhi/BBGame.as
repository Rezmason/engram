package net.rezmason.engram.games.busybodhi {		// IMPORT STATEMENTS	import flash.display.*;	import flash.events.*;	import flash.geom.*;		import net.rezmason.engram.modules.Game;	import net.rezmason.utils.Hat;		internal final class BBGame extends Game {				// INSTANCE PROPERTIES		private static const TRACK_REMOVED_EVENT:BBEvent = new BBEvent(BBEvent.TRACK_REMOVED);		private static const TRACK_ADDED_EVENT:BBEvent = new BBEvent(BBEvent.TRACK_ADDED);		private static const TRACK_SETTLED_EVENT:BBEvent = new BBEvent(BBEvent.TRACK_SETTLED);		private static const TURNING_POINT_EVENT:BBEvent = new BBEvent(BBEvent.TURNING_POINT);		private static const MAX_ROUND_SCORE:int = 2000;		private static const PEAK_SPEED:int = 100;		private var _comboString:String, comboTime:int;		private var tracks:Array, crazyTrack:Track = new Track(false);		private var _panic:Number, _craziness:Number;		private var _pointer:Number;		private var _continuous:Boolean;		private var _score:int, _roundScore:int;				// PUBLIC METHODS				override public function reset(event:Event = null):void {			_comboString = "";			comboTime = 0;			tracks = [];			crazyTrack.clear();			addTrack();			_panic = 0;			_craziness = 0;			_pointer = 0;			_continuous = false;			_score = 0;			_roundScore = 0;					}				internal function resetRoundScore():void {			_roundScore = 0;		}				internal function get score():int {			return _score;		}				override public function gameOver():void {						super.gameOver();		}				public function debug():void {			/*			var combo:String = "!";			var grains:Array = [1, 2, 3, 4];			while (grains.length) {				var grain:int = int(Math.random() * grains.length);				combo = tracks[0].addCombo(grains[grain]);				if (combo == null) {					grains.splice(grain, 1);				} else {					trace(combo);				}			}			trace("_____________");			//tracks[0].spew();			*/		}				// INTERNAL METHODS				internal function initialize():void {			trace("Initialize game");			resetRoundScore();			tracks[0].addTile();			tracks[0].spew();		}				internal function addTrack():int {			var returnVal:int;			for (var ike:int = 0; ike < tracks.length + 1; ike++) {				if (!tracks[ike]) {					returnVal = ike;					break;				}			}			tracks[returnVal] = new Track();			TRACK_ADDED_EVENT.trackIndex = returnVal;			dispatchEvent(TRACK_ADDED_EVENT);			return returnVal;		}				internal function removeTrack(trackIndex):void {			tracks[trackIndex].clear();			tracks.splice(trackIndex, 1);			if (_pointer == trackIndex && _pointer != 0) {				_pointer--;			}			TRACK_REMOVED_EVENT.trackIndex = trackIndex;			dispatchEvent(TRACK_REMOVED_EVENT);		}				internal function bump(direction:Number = 1):void {			_pointer += direction;						if (_continuous) {				if (_pointer < 0) {					_pointer = 0;				}				if (_pointer > tracks.length) {					_pointer = tracks.length;				}			} else {				if (_pointer < 0) {					_pointer = 0;				}				if (_pointer > tracks.length - 1) {					_pointer = tracks.length - 1;				}			}		}				internal function get speed():int {			var averageSpeed:int = 0;			for (var ike:int = 0; ike < tracks.length; ike++) {				averageSpeed += tracks[ike].speed;			}			return averageSpeed / tracks.length;;		}				internal function get continuous():Boolean {			return _continuous;		}				internal function set continuous(value:Boolean):void {			if (!_continuous && value) {				_pointer += 0.5;			}			_continuous = value;		}				internal function get numTracks():int {			return tracks.length;		}				internal function updateTracks():void {			for (var ike:int = 0; ike < tracks.length; ike++) {				var currentTrack:Track = tracks[ike];				currentTrack.updateTiles();				if (currentTrack.settled) {					TRACK_SETTLED_EVENT.trackIndex = ike;					dispatchEvent(TRACK_SETTLED_EVENT);				}				_panic; // adjust the panic level				if (currentTrack.full) {					if (tracks.length > 1) {						removeTrack(ike);					} else {						gameOver();					}				}			}						var slippedTiles:Array = crazyTrack.updateTiles();			for (ike = 0; ike < slippedTiles.length; ike++) {				crazyTrack.removeTile(slippedTiles[ike]);				_craziness; // adjust craziness			}		}				internal function push(beat:Beat):void {			if (_comboString.length) {				comboTime += beat.time;			}			_comboString += beat.key;			trace("combo string:", _comboString);		}				internal function cancelCombo():void {			_comboString = "";			comboTime = 0;		}		internal function get comboString():String {			return _comboString;		}				internal function findMatches():Array {			var _matches:Array = crazyTrack.find(_comboString);			if (!_continuous) {				_matches.push.apply(null, tracks[_pointer].find(_comboString));			}			return _matches;		}				internal function removeExactMatch(cleared:Boolean = false):String {			var _exactMatch:String;			var _matches:Array = crazyTrack.find(_comboString, true);			if (_matches.length == 1) {				if (cleared) {					// adjust craziness					_craziness;				}				crazyTrack.removeTile(_matches[0]);				crazyTrack.spew();			} else if (!_continuous) {				_matches.push.apply(null, tracks[_pointer].find(_comboString, true));				if (_matches.length == 1) {					tracks[_pointer].removeTile(_matches[0], cleared, comboTime);					tracks[_pointer].spew();				}							}						if (_matches.length == 1) {				_exactMatch = _matches[0];				if (cleared) {					_score; // add points to score					if (_score - _roundScore > MAX_ROUND_SCORE) {						// switch out					}					if (speed > PEAK_SPEED) {						decideEnding();					}				}			}			return _exactMatch;		}				internal function decideEnding():void {			// decide on an ending			TURNING_POINT_EVENT.ending = BBEnding.LOOPY;			dispatchEvent(TURNING_POINT_EVENT);		}	}}