package net.rezmason.engram.games.busybodhi {		// IMPORT STATEMENTS	import flash.display.Sprite;	import flash.events.Event;		import net.rezmason.engram.modules.ModuleView;		internal final class BBView extends ModuleView {				// INSTANCE PROPERTIES		private var _game:BBGame;		private var background:Sprite = new Sprite;		private var trackLayer:Sprite = new Sprite;		private var tiles:Object = {}, tracks:Array = [];				public function BBView(game:BBGame):void {						_game = game;						addChild(background);			addChild(trackLayer);						_game.addEventListener(BBEvent.TRACK_ADDED, makeTrackSprite);			_game.addEventListener(BBEvent.TRACK_REMOVED, killTrackSprite);			_game.addEventListener(BBEvent.TILE_ADDED, makeTileSprite);			_game.addEventListener(BBEvent.TILE_CLEARED, clearTileSprite);						//resize();		}				// GETTERS & SETTERS				override public function get centerpiece():Object {			return super.centerpiece;		}				// PUBLIC METHODS				override public function reset():void {			tiles = {};			tracks = [];		}		override public function resize(ratio:Number = 1):void {					}				// INTERNAL METHODS				internal function clearComboGlyphs(success:Boolean = false):void {			if (success) {				trace("view: !!!");			} else {				trace("view: ___");			}		}				internal function updateComboGlyphs():void {			trace("view: combo string:", _game.comboString);		}				internal function lightTileSprites(tileCombos:Array):void {			for (var ike:int = 0; ike < tileCombos.length; ike++) {				tiles[tileCombos[ike]].light(tileCombos[ike].length);			}		}				internal function makeTrackSprite(event:BBEvent):void {			trace("view: make track sprite", event.trackIndex);			var track:TrackSprite = new TrackSprite();			tracks[event.trackIndex] = track;			trackLayer.addChild(track);			track.land();			// place the track sprite			// push the other track sprites around		}				internal function killTrackSprite(event:BBEvent):void {			trace("view: kill track sprite", event.trackIndex);			var track:TrackSprite = tracks[event.trackIndex];			track.die();			track.addEventListener(Event.COMPLETE, removeDeadTrack, false, 0, true);		}				internal function dissolveTracks(event:Event):void {			// blur and alpha out the track layer		}				internal function makeTileSprite(event:BBEvent):void {			trace("view: make tile sprite", event.trackIndex, event.combo);			var tile:TileSprite = makeTile();			tracks[event.trackIndex].addChild(tile);			tile.appear();			tiles[event.combo] = tile;			// place the tile sprite		}				internal function clearTileSprite(event:BBEvent):void {			trace("view: kill track sprite", event.trackIndex, event.combo);			var tile:TileSprite = tiles[event.combo];			tiles[event.combo] = undefined;			tile.clear();			tile.addEventListener(Event.COMPLETE, removeDeadTile, false, 0, true);		}				internal function updateTileSprites(event:Event = null):void {			for (var prop:String in tiles) {				var tile:TileSprite = tiles[prop];				// get the tile sprite's position				// place the tile sprite			}		}				// PRIVATE & PROTECTED METHODS				private function removeDeadTrack(event:BBEvent):void {			var track:TrackSprite = tracks[event.trackIndex] as TrackSprite;			trackLayer.removeChild(track);		}				private function removeDeadTile(event:BBEvent):void {			var tile:TileSprite = tiles[event.combo] as TileSprite;			tile.parent.removeChild(tile);		}				private function makeTile():TileSprite {			// decide on which type of tile sprite to make			return new TileSprite;		}	}}