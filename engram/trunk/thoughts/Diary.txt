Diary:

5/20/08: A complicated API can be meticulously pieced apart and explored with impunity by creating a "testbed"- a simple scenario where you can prod it without affecting your main code.

5/21/08: If a system is offered to the public, and it is intended to work across bridges, it is the system developer's responsibility to not only make this work, but to completely encapsulate it, freeing the public from worrying about its functionality.

5/22/08: The difference between programming and computer science: 
Programming is the Writing of instructions. Like most other creative processes, it has a social component, although it is often overlooked. Programming, like architecture, has the capability to bring people together, to design rich and complex communities and societies. It primely intends to produce systems that solve problems on the social plane. In contrast, computer science is the Study of instructions. It intends to solve problems in computability and efficiency, and often forgoes the tasks of implementation and testing. Because of this, it does not approach the social plane, let alone intersect it. Although computer science benefits society, it does not cultivate society. An exception to this is the design of programming languages, an oddball so detached in its focus from its brethren that it very well may be a division of linguistics masquerading as a computer science.

5/23/08: Opening your source for free makes a statement. Treating people's contributions to your platform as untrustworthy makes a statement. Treating your own contributions as untrustworthy makes a statement.

"Chain reaction"-style recursive functions- the type of recursive function whose logic only affects lesser scopes- have the advantage of being transformable into a non-recursive function that pushes the recursive arguments onto a list with no public access to its interior elements (the ones that are not the first and last elements). Whereas all recursions can be transformed into iterations acting on a list, the behavior of "chain reaction" recursive functions guarantees that the traversal of this list can always proceed from the first element to the last, without backtracking. Since event systems and other implementations of the Observer pattern often use lists whose elements are processed from start to finish, a chain reaction can be rewritten to piggyback on top of the event system.

UPDATE: Piggybacking on the event system will actually cause a stack overflow in Flash, because functions that listen for events are considered to be in the scope of the function that dispatched the event. Other queues can still be used.

5/28/08: Working on this project while I'm on vacation has proven pretty much impossible. I'm beginning to wonder, based on my experience this week and during my last internship, whether I'll be able to put as much of my time into the project this summer as I hoped.

Tonight, after a short nap, I will begin a significant refactoring of my module loading code. Refactoring is undergone when code works but is poorly implemented; either it runs too slowly, it is inflexible, or its implementation is too convoluted to be understood. Tonight's refactoring (which would have been May 26th's refactoring) is not just the rewriting and rearranging of code, but the redefinition of classes and the roles that they play; the design is being improved on a higher level than simple logic structure. Because of this, I think "refactoring" is an insufficient label. What I'm doing is more akin to shuffling the employees of a company: promoting and demoting, hiring and firing entities that make up the company in order for it to run more smoothly. Fortunately I have no unions to worry about.

5/30/08: Reorganized all the code, and now everything looks and feels much better. The code is more presentable, and presentable code is important when you're sharing it with other people.

I'll be experimenting with a tweak to the color managing system that will allow nonuniform, gradual changes to occur in objects' coloration, rather than the current uniform, direct change. This may slow things down, so I'll probably have it trigger only if Effects are turned on in the Settings menu. (Edit: I ended up scrapping the nonuniform transition. There are other, more important things to implement.)

Speaking of which, the settings menu will need to be redone entirely soon, so that it can show more settings at once (probably by folding associated settings into categories, represented by tabs). I've got a whole interface planned out, which I'll get to later. Getting ahead of myself a bit, but that's never overburdened me before, has it?

5/31/08: Documentation probably should have begun months ago. The Mover class looks pretty alien, now that I'm trying to improve it. I'm hoping that documentation can occur in one fell swoop, just like the final going over where I'll check every namespace to ensure encapsulation; but the odds are at some point soon it will be costlier to stave off documentation than to get it over with, as arduous as it is. Also this is an indication that my coding style evolves with a frequency of at most six months.

6/5/08: I've started work at my summer internship, but progress on this project has continued. Last night at FCNY, Tom (the guy in charge I suppose) asked me to present my project at some point, so I'm going to write an outline covering the more interesting design decisions I've made over the past six months. No easy task.

While implementing GUIError this morning (it's thrown when GUI classes are misused), it occurred to me that not all of the module developers will have Strict Mode turned on, and although I'll suggest it, I can't anticipate that they will all use this feature. GUIError's job is actually performed by Strict Mode's compiler errors, but it's still a good idea to implement it.

Visio, a Microsoft Office product similar to OmniGraffle, is an industry standard for producing wireframes and prototypes- two powerful UX tools that I'm taking up at work. With no project currently demanding my time, I'm familiarizing myself with Visio by wireframing the new (read: intimidating) settings menu. I'm trying to be careful about how much of my work blends into my project, as this could lead to some hairy consequences. Nothing I can't handle.

6/6/08: Before working on the settings menu, I've decided to reorganize the current classes to relinquish some useful classes from the engram package. This will make them easier to use on projects independent of Engram. Tonight is a Friday night, so I'll have a chance to also improve the gui package (previously known as the ux package), expanding but also strengthening it with new interface elements and some foundation classes. I might be able to use the gui package to eventually create an advanced prototyping AIR app for the UX folks at Razorfish. They currently use several tools for prototyping, but none of them are absolutely ideal for the task; I think that the current means of automatically producing prototypes- flattening wireframes into tables and inserting links- falls short. Or maybe not. We'll see.

The GrimySurface class has received some more attention lately. It now sports what may be interpreted at first as a stray shoe print. Tonight I'll be asking forum folks and FCNY which tweening system I should use, in place of the built-in fl tween. This will allow more devs to contribute to the project, without forcing Flash CS3 onto them.

6/10/08: I've split the gritty texture and grimy texture segments of the GrimySurface class, so that they can be applied individually. This is because my friend and coworker Zak suggested an aesthetic change that I dismissed, but now can't stop thinking about. Unfortunately, I still haven't gotten the change to work, because it involves the complex world of fills and strokes, and how fills count and strokes don't (oftentimes).

Something I should have written about earlier is my style of development, which I call "stub-based". A "stub" is a mix between a placeholder and a traffic cone- it marks a point where progress was halted and resources redirected, but it encloses the incomplete work like a tarp over a construction site, protecting what's there until work can begin again. Stubs have two interesting incidental features; based on its implementation, a stub can communicate to the developer the level of abruptness reached when progress halted and the stub was made, and when a stub is removed and progress resumes, the point where the stub once was usually has a residual stubbiness to it. Stubs segment progress into observable chunks

I learned today that every statement made before the constructor is written gets broken down into two parts: the variable declaration (if there is one) and the rest of the statement. These statements are stuck in the beginning of the constructor, whether you realize it or not. So, if you have a subclass whose constructor sets the value of a protected property before calling the superclass's constructor, the superclass may set the value of the property back to what it is stated as in the superclass's variable declarations. Tricky tricky tricky.

6/18/08: Good news! My boss and mentor at my job have actually suggested that I find a portion of my thesis project to work on (among other things) during my internship. I'll be designing the developers' community site, based on what I'll research and design during the summer.

My classes have been separated into several packages, and I've extended a bunch of them to make them easier to use and more powerful. I'll soon have an Alert class, which will be a resizable object capable of displaying contextual messages to the user. I still need to redesign the settings menu, but I'm getting closer to the point where I'm ready to do so. I'll need to extend Mover (and possibly move it to the gui package, formerly the ux package) so that it can be set to move objects in multiple, controlled ways. I'm also removing all code dependencies on the Flash tween classes, including the tetris module, and I'm producing a ton of new gui elements. ModuleManager will need to be able to load a single module- the one it will receive when a module is dropped on the application- and eventually, it will need to include logic that decides which games to serve up and when.

12/31/08: A lot of time missing between this entry and the last one. The system for tweening menus has been modified to swap them between six fixed points on a hexagon that's centered around the new Canvas object, which parallaxes and rotates- that was all done months ago. Most recently, the grid system in the Drill menu has been repurposed to allow the player to specify the games in their mixes without going into the settings menu, which was the wrong place for them to begin with. Speaking of which, I still need to put the settings menu together. If I get my act together, I'll have it ready before the next semester begins (Jan. 12th), so I can concentrate on the more major parts of the game- the art system, the buffer system, and the MODULES THEMSELVES for crying out loud. I need to remember to allow time for user testing and devloping a promotional site.

