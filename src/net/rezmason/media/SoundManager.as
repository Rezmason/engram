package net.rezmason.media {		// IMPORT STATEMENTS	import flash.media.Sound;	import flash.media.SoundChannel;	import flash.media.SoundMixer;	import flash.media.SoundTransform;		/**	*	<code>SoundManager</code> can take in a list of sounds and loops,	*	and then play them on different channels.	*	<p>Oftentimes in a Flash game, different groups of sounds	*	are meant to only be played one at a time; but those sounds	*	are also meant to be played simultaneously with other game sounds.	*	<code>SoundManager</code> intends to simplify the handling of these behaviors.</p>	*		*	<p><code>SoundManager</code> is a Singleton; there is only one SoundManager instance,	*	and the sounds it handles are accessible from anywhere inside an application.</p>	*		*	@author Jeremy Sachs	*	@langversion	ActionScript 3.0	*	@playerversion	Flash 9	*	@tiptext	*/	public class SoundManager {		// CLASS PROPERTIES		private static const _INSTANCE:SoundManager = new SoundManager(SingletonEnforcer);				// INSTANCE PROPERTIES		private var _prepped:Boolean = false;		private var sounds:Object = {};		private var defaultChannels:Object = {};		private var channels:Array = [];		private var loops:Object = {};		/**		*	Calling the <code>SoundManager</code> constructor throws an <code>ArgumentError</code>		*	exception. You <i>can</i>, however, obtain the <code>SoundManager</code> instance		*	with the <code>INSTANCE</code> property.		*			*/		public function SoundManager(enf:Class):void {			if (enf != SingletonEnforcer) {				throw new ArgumentError("You do not create a SoundManager; it is a Singleton.");			}		}				// STATIC GETTERS & SETTERS				/**		*	The <code>SoundManager</code> instance.		*		*/		public static function get INSTANCE():SoundManager {			return _INSTANCE;		}				// PUBLIC METHODS				/**		*	Subscribes sounds and their behaviors to the <code>SoundManager</code>.		*		*	@param	obj	 An Object whose properties are the names of sounds,		*	and whose values are references to <code>Sound</code> objects themselves.		*	@param	chan	An Object like <code>obj</code>, except that its values		*	are integers representing the default channel for the corresponding <code>Sound</code>		*	to be played.		*	@param	lp	An Obejct like <code>obj</code>, except that its values		*	are loop representations.		*	<p>A loop representation is an Array whose first, second and third elements are the names		*	of a looping sound, a beginning sound and an ending sound which are specified in the		*	<code>obj</code> object.</p>		*	@see flash.media.Sound		*/		public function enlistSounds(obj:Object, chan:Object = null, lp:Object = null):void {						// first, prep the sound system.			if (!_prepped) {				prepareSystem(obj);			}						// add sounds to proper sound object						for (var prop:String in obj) {				if (obj[prop] is Sound) {					sounds[prop] = obj[prop];				}			}						if (chan) {				for (prop in chan) {					if (sounds[prop] && chan[prop] is Number) {						defaultChannels[prop] = chan[prop];					}				}			}						if (lp) {				for (prop in lp) {					if (lp[prop] is Array) {						var arr:Array = lp[prop];						if (arr[0] is String) {							loops[prop] = new Loop(sounds[arr[0]], sounds[arr[1]], sounds[arr[2]]);						}					}				}			}		}				/**		*	Plays the specified sound.		*		*	@param	soundName	The name of the sound to play.		*	@param	volume	The volume at which to play the sound.		*	@param	chan	The channel on which to play the sound. If unspecified,		*	the sound's default channel is used.		*/		public function play(soundName:String, volume:Number = 1, chan:int = -1):void {			if (loops[soundName]) {				loops[soundName].play(volume);			} else if (sounds[soundName]) {				if (chan == -1 && defaultChannels[soundName]) {					chan = defaultChannels[soundName];				}								if (chan != -1) {					if (channels[chan]) {						channels[chan].stop();					}										channels[chan] = sounds[soundName].play();					channels[chan].soundTransform = new SoundTransform(volume);				} else {					sounds[soundName].play().soundTransform = new SoundTransform(volume);				}			}		}				/**		*	Stops the sounds playing on the specified channel.		*		*	@param	chan	The channel to silence.		*/		public function stopChannel(chan:int):void {			if (channels[chan]) {				channels[chan].stop();			}		}				/**		*	Stops all sounds systemwide.		*		*/		public function stopAll():void {			SoundMixer.stopAll();		}				/**		*	Stops the sounds playing in the specified loop		*		*	@param	soundName	The name of the sound loop to silence.		*/		public function stopLoop(soundName:String):void {			if (loops[soundName]) {				loops[soundName].stop();			}		}				// PRIVATE & PROTECTED METHODS				private function prepareSystem(obj:Object):void {			var beginner:Sound;			for (var prop:String in obj) {				if (obj[prop] is Sound) {					beginner = obj[prop];					break;				}			}						if (!beginner) {				return;			}						var beginnerChannel:SoundChannel = beginner.play();						if (beginnerChannel) {				beginnerChannel.soundTransform = new SoundTransform(0);			}			_prepped = true;		}	}}import flash.events.Event;import flash.events.TimerEvent;import flash.media.Sound;import flash.media.SoundChannel;import flash.media.SoundTransform;import flash.utils.Timer;internal class SingletonEnforcer{}internal class Loop {		internal static const BUFFER:int = 100;		internal var loopSound:Sound, beginSound:Sound, endSound:Sound;	internal var channel:SoundChannel, volume:Number = 1;	internal var timer:Timer = new Timer(0);		public function Loop(lS:Sound, bS:Sound = null, eS:Sound = null):void {		loopSound = lS;		beginSound = bS;		endSound = eS;		timer.addEventListener(TimerEvent.TIMER, playLoop, false, 0, true);	}		public function play(vol:Number = 1):void {				volume = vol;				if (channel) {			channel.stop();		}				if (beginSound) {			channel = beginSound.play();			channel.soundTransform = new SoundTransform(volume);			timer.delay = beginSound.length - BUFFER;			timer.start();			//channel.addEventListener(Event.SOUND_COMPLETE, playLoop, false, 0, true);		} else {			playLoop();		}	}		public function playLoop(event:Event = null):void {		if (loopSound) {			channel = loopSound.play();			channel.soundTransform = new SoundTransform(volume);			timer.reset();			timer.delay = loopSound.length - BUFFER;			timer.start();			//channel.addEventListener(Event.SOUND_COMPLETE, playLoop, false, 0, true);		}	}		public function stop():void {		if (channel) {			channel.stop();		}				timer.stop();				if (endSound) {			channel = endSound.play();		}	}}