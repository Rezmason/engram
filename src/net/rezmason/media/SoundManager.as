package net.rezmason.media {		// IMPORT STATEMENTS	import flash.media.Sound;	import flash.media.SoundChannel;	import flash.media.SoundMixer;	import flash.media.SoundTransform;		public class SoundManager {		// CLASS PROPERTIES		private static const _INSTANCE:SoundManager = new SoundManager(SingletonEnforcer);				// INSTANCE PROPERTIES		private var _prepped:Boolean = false;		private var sounds:Object = {};		private var defaultChannels:Object = {};		private var channels:Array = [];		private var loops:Object = {};		// CONSTRUCTOR		public function SoundManager(enf:Class):void {			if (enf != SingletonEnforcer) {				throw new ArgumentError("You do not create a SoundManager; it is a Singleton.");			}		}				// STATIC GETTERS & SETTERS				public static function get INSTANCE():SoundManager {			return _INSTANCE;		}				// PUBLIC METHODS				public function enlistSounds(obj:Object, chan:Object = null, lp:Object = null):void {						// first, prep the sound system.			if (!_prepped) {				prepareSystem(obj);			}						// add sounds to proper sound object						for (var prop:String in obj) {				if (obj[prop] is Sound) {					sounds[prop] = obj[prop];				}			}						if (chan) {				for (prop in chan) {					if (sounds[prop] && chan[prop] is Number) {						defaultChannels[prop] = chan[prop];					}				}			}						if (lp) {				for (prop in lp) {					if (lp[prop] is Array) {						var arr:Array = lp[prop];						if (arr[0] is String && arr[1] is String) {							loops[prop] = new Loop(sounds[arr[0]], sounds[arr[1]], sounds[arr[2]]);						}					}				}			}		}				public function play(soundName:String, volume:Number = 1, chan:int = -1):void {			if (loops[soundName]) {				loops[soundName].play(volume);			} else if (sounds[soundName]) {				if (chan == -1 && defaultChannels[soundName]) {					chan = defaultChannels[soundName];				}								if (chan != -1) {					if (channels[chan]) {						channels[chan].stop();					}										channels[chan] = sounds[soundName].play();					channels[chan].soundTransform = new SoundTransform(volume);				} else {					sounds[soundName].play().soundTransform = new SoundTransform(volume);				}			}		}				public function stopChannel(chan:int):void {			if (channels[chan]) {				channels[chan].stop();			}		}				public function stopAll():void {			SoundMixer.stopAll();		}				public function stopLoop(soundName:String):void {			if (loops[soundName]) {				loops[soundName].stop();			}		}				// PRIVATE METHODS				private function prepareSystem(obj:Object):void {			var beginner:Sound;			for (var prop:String in obj) {				if (obj[prop] is Sound) {					beginner = obj[prop];					break;				}			}						if (!beginner) {				return;			}						var beginnerChannel:SoundChannel = beginner.play();						if (beginnerChannel) {				beginnerChannel.soundTransform = new SoundTransform(0);			}			_prepped = true;		}	}}import flash.events.Event;import flash.media.Sound;import flash.media.SoundChannel;import flash.media.SoundTransform;import flash.utils.Timer;internal class SingletonEnforcer{}internal class Loop {		internal static const BUFFER:int = 100;		internal var loopSound:Sound, beginSound:Sound, endSound:Sound;	internal var channel:SoundChannel, volume:Number = 1;	internal var timer:Timer = new Timer(0);		public function Loop(lS:Sound, bS:Sound = null, eS:Sound = null):void {		loopSound = lS;		beginSound = bS;		endSound = eS;		timer.addEventListener("timer", playLoop, false, 0, true);	}		public function play(vol:Number = 1):void {				volume = vol;				if (channel) {			channel.stop();		}				if (beginSound) {			channel = beginSound.play();			channel.soundTransform = new SoundTransform(volume);			timer.delay = beginSound.length - BUFFER;			timer.start();			//channel.addEventListener(Event.SOUND_COMPLETE, playLoop, false, 0, true);		} else {			playLoop();		}	}		public function playLoop(event:Event = null):void {		if (loopSound) {			channel = loopSound.play();			channel.soundTransform = new SoundTransform(volume);			timer.reset();			timer.delay = loopSound.length - BUFFER;			timer.start();			//channel.addEventListener(Event.SOUND_COMPLETE, playLoop, false, 0, true);		}	}		public function stop():void {		if (channel) {			channel.stop();		}				timer.stop();				if (endSound) {			channel = endSound.play();		}	}}