package net.rezmason.display {	// IMPORT STATEMENTS	import flash.display.BlendMode;	import flash.display.DisplayObject;	import flash.display.GradientType;	import flash.display.Shape;	import flash.display.Sprite;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;		public final class Peeler extends Sprite {				// CLASS PROPERTIES		private static const FAT:uint = 10;				// INSTANCE PROPERTIES		private var _shiny:Boolean = true;		private var _shaded:Boolean = true;		private var _stickerFront:DisplayObject;		private var _stickerBack:DisplayObject;		private var _shadowMask:DisplayObject;		private var _shineMask:DisplayObject;		private var _axis:Shape = new Shape;		private var shadow:DisplayObject;		private var shine:DisplayObject;				private var _locked:Boolean = false;		private var maskOrigin:Point = new Point;		private var maskRect:Rectangle;		private var matrix:Matrix, matrix2:Matrix;		private var frontMask:DisplayObject;		private var backMask:DisplayObject;		private var backSide:Sprite = new Sprite;		private var frontSide:Sprite = new Sprite;				// CONSTRUCTOR		public function Peeler(__front:DisplayObject, __back:DisplayObject, __shad:DisplayObject, __shin:DisplayObject):void {						frontMask = makeMask();			backMask = makeMask();			shadow = makeShadow();			shadow.blendMode = BlendMode.MULTIPLY;			shine = makeShine();			shine.blendMode = BlendMode.SCREEN;						_stickerFront = __front;			_stickerBack = __back;			_shadowMask = __shad;			_shineMask = __shin;						addChild(frontSide);			addChild(backSide);						frontSide.addChild(_stickerFront);			frontSide.addChild(frontMask), frontMask.alpha = 0;			frontSide.addChild(shadow);			frontSide.addChild(_shadowMask);						backSide.addChild(_stickerBack);			backSide.addChild(backMask);			backSide.addChild(shine);			backSide.addChild(_shineMask);						update();		}				// GETTERS & SETTERS				public function get shiny():Boolean {			return _shiny;		}				public function set shiny(value:Boolean):void {			if (_shiny != value) {				_shiny = value;				update();			}		}				public function get shaded():Boolean {			return _shaded;		}				public function set shaded(value:Boolean):void {			if (_shaded != value) {				_shaded = value;				update();			}		}				public function get axisX():Number {			return _axis.x;		}				public function set axisX(value:Number):void {			_axis.x = value;			update();		}				public function get axisY():Number {			return _axis.y;		}				public function set axisY(value:Number):void {			_axis.y = value;			update();		}				public function get axisR():Number {			return _axis.rotation;		}				public function set axisR(value:Number):void {			_axis.rotation = value;			update();		}				public function get front():DisplayObject {			return _stickerFront;		}				public function set front(value:DisplayObject):void {			if (!contains(value)) _stickerFront = swap(_stickerFront, value);		}				public function get back():DisplayObject {			return _stickerBack;		}				public function set back(value:DisplayObject):void {			if (!contains(value)) _stickerBack = swap(_stickerBack, value);		}		public function get shadowMask():DisplayObject {			return _shadowMask;		}		public function set shadowMask(value:DisplayObject):void {			if (!contains(value)) _shadowMask = swap(_shadowMask, value);		}		public function get shineMask():DisplayObject {			return _shineMask;		}		public function set shineMask(value:DisplayObject):void {			if (!contains(value)) _shineMask = swap(_shineMask, value);		}				// PUBLIC METHODS				public function update():void {						addChild(_axis);						if (_locked) {				return;			}						maskRect = _stickerFront.getBounds(_axis);			maskRect.x -= FAT, maskRect.y -= FAT;			maskRect.width += 2 * FAT, maskRect.height += 2 * FAT;			frontSide.visible = (maskRect.x <= 0);			maskRect.width = Math.max(maskRect.width + maskRect.x, 0);			maskRect.x = 0;			if (maskRect.width > 0) {				backSide.visible = true;				matrix = _stickerFront.transform.matrix.clone();				matrix2 = _axis.transform.matrix.clone();				matrix2.invert();				matrix.concat(matrix2);				matrix.a *= -1;				matrix.c *= -1;				matrix.tx *= -1;				matrix.concat(_axis.transform.matrix);				_shineMask.transform.matrix = _stickerBack.transform.matrix = matrix;			} else {				backSide.visible = false;			}									if (_shiny || backSide.visible && frontSide.visible) {				maskOrigin = globalToLocal(_axis.localToGlobal(maskRect.topLeft));				updateTransform(frontMask);				updateTransform(backMask, true);				updateTransform(shadow, true);				updateTransform(shine, true);				showMasks();			} else {				hideMasks();			}						graphics.clear();			graphics.lineStyle(4, 0xFFFF00);			graphics.drawCircle(0, 0, 10);			graphics.drawCircle(_axis.x, _axis.y, 5);					}				public function lock():void {			_locked = true;		}				public function unlock():void {			_locked = false;			update();		}				// PRIVATE METHODS				private function updateTransform(target:DisplayObject, flip:Boolean = false):void {			target.rotation = 0;			target.width  = maskRect.width;			target.height = maskRect.height;						if (flip) {				target.scaleX *= -1;			}						target.x = maskOrigin.x;			target.y = maskOrigin.y;			target.rotation = _axis.rotation;		}				private function showMasks():void {						_shadowMask.visible = false;			_shineMask.visible = false;						if (!_stickerBack.mask) {				frontSide.blendMode = BlendMode.LAYER;				frontMask.blendMode = BlendMode.ALPHA;				_stickerBack.mask = backMask;				backMask.visible = frontMask.visible = true;								shadow.visible = _shaded;				shadow.mask = (_shaded ? _shadowMask : null);				_shadowMask.visible = _shaded;								shine.visible = _shiny;				shine.mask = (_shiny ? _shineMask : null);				_shineMask.visible = _shiny;			}		}		private function hideMasks():void {			if (_stickerBack.mask) {				frontSide.blendMode = BlendMode.NORMAL;				frontMask.blendMode = BlendMode.NORMAL;				_stickerBack.mask = null;				backMask.visible = frontMask.visible = false;								shadow.visible = false;				shadow.mask = null;				_shadowMask.visible = false;								shine.visible = false;				shine.mask = null;				_shineMask.visible = false;			}		}				private function makeMask():DisplayObject {			var returnVal:Sprite = new Sprite();			var shape:Shape = new Shape;			with (shape.graphics) {				lineStyle();				beginFill(0xFFFFFF);				drawRect(0, 0, 10, 10);				endFill();			}			returnVal.addChild(shape);			return returnVal;		}				private function makeShadow():DisplayObject {			var returnVal:Sprite = new Sprite();			var shape:Shape = new Shape;			var box:Matrix = new Matrix;			var colors:Array = [0x444444, 0xCCCCCC, 0xEEEEEE, 0xFFFFFF];			var ratios:Array = [0, 64, 128, 192];			box.createGradientBox(100, 100, 0, 0, 0);			with (shape.graphics) {				lineStyle();				beginGradientFill(GradientType.LINEAR, colors, [1, 1, 1, 1], ratios, box);				drawRect(0, 0, 100, 100);				endFill();			}			returnVal.addChild(shape);			return returnVal;		}				private function makeShine():DisplayObject {			var returnVal:Sprite = new Sprite();			var shape:Shape = new Shape;			var box:Matrix = new Matrix;			var colors:Array = [0x000000, 0xFFFFFF, 0xFFFFFF, 0x000000];			var ratios:Array = [0, 84, 102, 255];			box.createGradientBox(100, 100, 0, 0, 0);			with (shape.graphics) {				lineStyle();				beginGradientFill(GradientType.LINEAR, colors, [1, 1, 1, 1], ratios, box);				drawRect(0, 0, 100, 100);				endFill();			}			returnVal.addChild(shape);			return returnVal;		}				private function swap(d1:DisplayObject, d2:DisplayObject):DisplayObject {			if (d2) {				with (d1.parent) {					addChildAt(d2, getChildIndex(d1));					removeChild(d1);				}								update();				}			return d2 || d1;		}	}}