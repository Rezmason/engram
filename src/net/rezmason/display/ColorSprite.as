package net.rezmason.display {		// IMPORT STATEMENTS	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.geom.ColorTransform;		public class ColorSprite extends Sprite {				// CLASS PROPERTIES		private static const PLAIN_CT:ColorTransform = new ColorTransform;		private static const GRRR:String = "The supplied DisplayObject must be a colorChild of the caller.";		private static const GUEST_GRRR:String = "The supplied Object must be a colorGuest of the caller.";		private static const SET_COLORS_GRRR:String = "The supplied Object must have a valid setColors() function.";		private static const ARGUMENT_ERROR:ArgumentError = new ArgumentError(GRRR);		private static const ARGUMENT_GUEST_ERROR:ArgumentError = new ArgumentError(GUEST_GRRR);		private static const SET_COLORS_ERROR:Error = new Error(SET_COLORS_GRRR);				// INSTANCE PROPERTIES		public var colorizeEnabled:Boolean = false, colorizeChildren:Boolean = true, colorizeGuests:Boolean = true;		private var _colorChildren:Array = [], _colorChildIndices:Array = [];		private var _colorGuests:Array = [], _colorGuestIndices:Array = [];		private var setColorEvent:ColorEvent = new ColorEvent(ColorEvent.SET_COLOR);		private var _colorTransforms:Array = [];		private var _touched:Boolean = false;						public function ColorSprite():void {			//addEventListener(ColorEvent.SET_COLOR, setColorsFromEvent);		}				// GETTERS & SETTERS				public function get numColorChildren():int {			return _colorChildren.length;		}				public function get colorChildren():Array {			return _colorChildren.slice();		}				public function get colorChildIndices():Array {			return _colorChildIndices.slice();		}				public function get numColorGuests():int {			return _colorGuests.length;		}				public function get colorGuests():Array {			return _colorGuests.slice();		}				public function get colorGuestIndices():Array {			return _colorGuestIndices.slice();		}				// PUBLIC METHODS				public function addColorChild(child:DisplayObject, pIndex:int = 0):void {			var oldAlpha:Number;						if (colorOfChild(child) != -1) {				removeColorChild(child);			}						_colorChildren.push(child);			_colorChildIndices.push(pIndex);						if (_colorTransforms && _colorTransforms.length) {				if (child is ColorSprite) {					(child as ColorSprite).setColors(_colorTransforms, pIndex);				} else {					pIndex = Math.max(0, Math.min(_colorTransforms.length - 1));					oldAlpha = child.alpha;					child.transform.colorTransform = _colorTransforms[pIndex];					child.alpha = oldAlpha;				}			}		}				public function addColorGuest(obj:Object, pIndex:int = 0):void {			try {				if (!obj.setColors || !obj.setColors is Function) {					throw SET_COLORS_ERROR;				}			} catch (error:Error) {				throw SET_COLORS_ERROR;			}						if (colorOfChild(obj, false) != -1) {				removeColorGuest(obj);			}						_colorGuests.push(obj);			_colorGuestIndices.push(pIndex);						if (_colorTransforms && _colorTransforms.length) {				obj.setColors(_colorTransforms, pIndex);			}		}				public function removeColorChild(child:DisplayObject):void {			var ike:int = _colorChildren.indexOf(child);			if (ike != -1) {				_colorChildren.splice(ike, 1);				_colorChildIndices.splice(ike, 1);				child.transform.colorTransform = PLAIN_CT;			} else {				throw ARGUMENT_GUEST_ERROR;			}		}				public function removeColorGuest(obj:Object):void {			if (!obj) {				throw new ArgumentError("removeColorGuest() does not accept a null value.");			}			var ike:int = _colorGuests.indexOf(obj);			if (ike != -1) {				_colorGuests.splice(ike, 1);				_colorGuestIndices.splice(ike, 1);				obj.setColors();			} else {				throw ARGUMENT_ERROR;			}		}				public function setColors(colorTransforms:Array, myIndex:int = 0):void {			var ike:int;			var pIndex:int;			var randomNumber:Number;			var oldAlpha:Number;						if (_touched) {				return;			}						_touched = true;						if (myIndex < 0) {				myIndex = 0;			} else if (myIndex > colorTransforms.length - 1) {				myIndex = colorTransforms.length - 1;			}						for (ike = 0; ike < colorTransforms.length; ike += 1) {				_colorTransforms[ike] = colorTransforms[ike] = gleanCTData(colorTransforms[ike]);			}						if (colorizeChildren) {				setColorEvent.colorTransforms = colorTransforms;				for (ike = 0; ike < _colorChildren.length; ike += 1) {					if (_colorChildren[ike] is ColorSprite) {						setColorEvent.pIndex = _colorChildIndices[ike];						//_colorChildren[ike].dispatchEvent(setColorEvent);						_colorChildren[ike].setColors(colorTransforms, _colorChildIndices[ike]);					} else {												pIndex = _colorChildIndices[ike];												if (pIndex < 0) {							pIndex = 0;						} else if (pIndex > colorTransforms.length - 1) {							pIndex = colorTransforms.length - 1;						}												oldAlpha = _colorChildren[ike].alpha;						_colorChildren[ike].transform.colorTransform = colorTransforms[pIndex];						_colorChildren[ike].alpha = oldAlpha;					}				}			}						if (colorizeGuests) {				for (ike = 0; ike < _colorGuests.length; ike += 1) {					_colorGuests[ike].setColors(colorTransforms, _colorGuestIndices[ike]);				}			}						if (colorizeEnabled) {				transform.colorTransform = colorTransforms[myIndex];			}						_touched = false;		}				public function colorOfChild(obj:Object, trusted:Boolean = true):int {						var returnVal:int = (trusted ? _colorChildren.indexOf(obj):_colorGuests.indexOf(obj));						if (returnVal != -1) {				returnVal = (trusted ? _colorChildIndices[returnVal] : _colorGuestIndices[returnVal]);			}						return returnVal;		}				// PRIVATE METHODS				private function gleanCTData(obj:Object):ColorTransform {			var returnValue:ColorTransform;			if (obj is ColorTransform) {				return obj as ColorTransform;			} else if (obj is uint || obj is int) {				returnValue = new ColorTransform();				returnValue.color = obj as uint;				returnValue.redMultiplier = returnValue.redOffset / 0xFF;				returnValue.greenMultiplier = returnValue.greenOffset / 0xFF;				returnValue.blueMultiplier = returnValue.blueOffset / 0xFF;				returnValue.redOffset = returnValue.greenOffset = returnValue.blueOffset = 0;				return returnValue;			} else {				try {					returnValue = new ColorTransform(						obj.redMultiplier, 						obj.greenMultiplier, 						obj.blueMultiplier					);					return returnValue;				} catch (error:Error) {					throw new ArgumentError("Input object needs to have properties similar to ColorTransform.")				}			}			return PLAIN_CT;		}				private function setColorsFromEvent(event:ColorEvent):void {			setColors(event.colorTransforms, event.pIndex);		}	}}