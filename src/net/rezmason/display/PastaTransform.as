package net.rezmason.display {	public class PastaTransform {		internal static const STROKE_LIMIT:Number = 255;		internal static const CORNER_RADIUS_LIMIT:Number = STROKE_LIMIT;		internal static const CURVATURE_LIMIT:Number = 360;		internal var _shortcut:Boolean = false;		internal var _polarity:int = 1;		internal var _curvature:Number;		internal var _wavelength:Number;		internal var _length:Number;		internal var _color:int;		internal var _thickness:Number;		internal var _roundCap:Number = 0;		internal var _offset:Number = 0;		public function PastaTransform(		   __thickness:Number = 30, 		   __length:Number = 300, 		   __color:int = 0x000000, 		   __curvature:Number = 135, 		   __wavelength:Number = 150):void {			thickness = __thickness;			length = __length;			curvature = __curvature;			color = __color;			wavelength = __wavelength;		}		public function clone():PastaTransform {			var returnVal:PastaTransform = new PastaTransform(_thickness,_length,_color,_curvature,_wavelength);			returnVal.roundCap = _roundCap;			returnVal.offset = _offset;			returnVal.shortcut = _shortcut;			return returnVal;		}		public function absorb(target:Object):Boolean {			var isDirty:Boolean = false;			if (target is PastaTransform) {				var spew:Object = target.spew();				isDirty = _thickness != spew.thickness ? (_thickness = spew.thickness) || true : isDirty;				isDirty = _length != spew.length ? (_length = spew.length) || true : isDirty;				isDirty = _curvature != spew.curvature ? (_curvature = spew.curvature) || true : isDirty;				isDirty = _wavelength != spew.wavelength ? (_wavelength = spew.wavelength) || true : isDirty;				isDirty = _color != spew.color ? (_color = spew.color) || true : isDirty;				isDirty = _roundCap != spew.roundCap ? (_roundCap = spew.roundCap) || true : isDirty;				isDirty = _offset != spew.offset ? (_offset = spew.offset) || true : isDirty;				isDirty = _shortcut != spew.shortcut ? (_shortcut = spew.shortcut) || true : isDirty;							isDirty = _polarity != spew.polarity ? (_polarity = spew.polarity) || true : isDirty;			} else {				for (var prop:String in target) {					try {						this[prop] = target[prop];					} catch (error:Error) {}				}				isDirty = true;			}						return isDirty;		}		public function get thickness():Number {			return _thickness;		}		public function set thickness(value:Number):void {			_thickness = valid(value,0,STROKE_LIMIT);		}		public function get length():Number {			return _length;		}		public function set length(value:Number):void {			_length = valid(value);		}		public function get curvature():Number {			return _curvature * _polarity;		}		public function set curvature(value:Number):void {			_polarity = valid(value, -1) > 0 ? 1 : -1;			_curvature = valid(value * _polarity, 0, CURVATURE_LIMIT);		}		public function get wavelength():Number {			return _wavelength;		}		public function set wavelength(value:Number):void {			_wavelength = valid(value,0);		}		public function get color():int {			return _color;		}		public function set color(value:int):void {			_color = int(valid(value));		}		public function get roundCap():Number {			return _roundCap;		}		public function set roundCap(value:Number):void {			_roundCap = Math.min(CORNER_RADIUS_LIMIT,valid(value));		}		public function get offset():Number {			return _offset;		}		public function set offset(value:Number):void {			_offset = valid(value, 0); // change eventually		}				public function get shortcut():Boolean {			return _shortcut;		}				public function set shortcut(value:Boolean):void {			_shortcut = value;		}				internal static function get crappyTransform():PastaTransform {			var returnVal:PastaTransform = new PastaTransform();			returnVal.crapOut();			return returnVal;		}		internal function spew():Object {			return {				thickness:_thickness,				length:_length,				curvature:_curvature,				color:_color,				wavelength:_wavelength,				roundCap:_roundCap,				offset:_offset,				shortcut:_shortcut,								polarity:_polarity			};		}				internal function crapOut():void {			_thickness = NaN;			_length = NaN;			_curvature = NaN;			_wavelength = NaN;			_color = NaN;			_roundCap = NaN;			_offset = NaN;			_shortcut = false;						_polarity = NaN;		}				private static function valid(value:Number, min:Number = 0, max:Number = Infinity):Number {			if (! isNaN(value)) {				if (min > value) {					return min;				} else if (max < value) {					return max;				} else {					return value;				}			}			return min;		}	}}