package net.rezmason.display {		// IMPORT STATEMENTS	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Rectangle;		/**	*	Sprite that automatically arranges display objects into a grid.	*		*	@author Jeremy Sachs	*	@langversion	ActionScript 3.0	*	@playerversion	Flash 9	*	@tiptext	*/	public class Grid extends Sprite {				// INSTANCE PROPERTIES		private var _full:Boolean = false;		private var _cellWidth:int = 64, _spacing:int = 4;		private var _maxWidth:int = 0, _maxHeight:int = 0;		private var _column:int = 0, _row:int = 0;		private var rectangle:Rectangle;		private var _maxColumns:int = 0, _maxRows:int = 0;		private var ready:Boolean = false;		private var placedObjects:Array = [];		private var _fill:Array = [GridFill.LEFT_TO_RIGHT, GridFill.TOP_TO_BOTTOM];		private var _columnsFirst:Boolean = true;				/**		*	Creates a new Grid instance.		*		*	@param	__maxWidth	 The maximum width of the grid.		*	@param	__maxHeight	 The maximum height of the grid.		*	@param	__cellWidth	 The size of a grid element on its largest axis.		*	@param	__spacing	 The distance to set grid elements apart from one another.		*/		public function Grid(__maxWidth:int = 0, __maxHeight:int = 0, __cellWidth:int = 64, __spacing:int = 4):void {						try {				maxWidth = __maxWidth;				maxHeight = __maxHeight;				cellWidth = __cellWidth;				spacing = __spacing;				ready = true;				refresh();			} catch (error:Error) {				throw new Error("Grid constructor failed:", error.message);			}					}				// GETTERS & SETTERS				/**		*	The size of a grid element on its largest axis.		*		*/		public function get cellWidth():int {			return _cellWidth;		}				/**		*	@private		*		*/		public function set cellWidth(value:int):void {			if (value > 0) {				_cellWidth = value;			} else {				throw new Error("The cell width must be a positive integer.");			}			refresh();		}				/**		*	The distance to set grid elements apart from one another.		*		*/		public function get spacing():int {			return _spacing;		}				/**		*	@private		*		*/		public function set spacing(value:int):void {			if (value >= 0) {				_spacing = value;			} else {				throw new Error("The spacing must be a nonnegative integer.");			}			refresh();		}				/**		*	The maximum width of the grid.		*		*/		public function get maxWidth():int {			return _maxWidth;		}				/**		*	@private		*		*/		public function set maxWidth(value:int):void {			if (value >= 0) {				_maxWidth = value;			} else {				throw new Error("The maximum width must be a nonnegative integer.");			}			refresh();		}				/**		*	The maximum height of the grid.		*		*/		public function get maxHeight():int {			return _maxHeight;		}				/**		*	@private		*		*/		public function set maxHeight(value:int):void {			if (value >= 0) {				_maxHeight = value;			} else {				throw new Error("The maximum height must be a nonnegative integer.");			}			refresh();		}				/**		*	Determines whether any more elements can be added to the grid.		*		*/		public function get full():Boolean {			return _full;		}				/**		*	Determines whether there are no elements in the grid.		*		*/		public function get empty():Boolean {			return (!placedObjects.length);		}				/**		*	The rule set for which to fill the grid.		*		*/		public function get fill():Array {			return _fill.slice();		}				/**		*	@private		*		*/		public function set fill(value:Array):void {			if (!GridFill.isNotAType(value[0]) && !GridFill.isNotAType(value[1])) {				_fill = value.slice(0, 2);				_columnsFirst = (_fill[0] == GridFill.RIGHT_TO_LEFT || _fill[0] == GridFill.LEFT_TO_RIGHT);			}			refresh();		}				// PUBLIC METHODS				/**		*	Adds an element to the grid, if it is not full.		*			*	@param	dObj	The display object to add.		*	<p>A display object can only occupy one cell at a time in a grid.</p>		*		*/		public function place(dObj:DisplayObject):void {			if (placedObjects.indexOf(dObj) == -1) {				placedObjects.push(dObj);				addCell(dObj);			} else {				throw new Error("You cannot place the same display object twice in the same Grid.");			}		}				/**		*	Removes an element from the grid.		*			*	@param	dObj	The display object to remove.		*		*/		public function remove(dObj:DisplayObject):void {			var position:int = placedObjects.indexOf(dObj);			if (position == -1) {				throw new Error("The supplied display object must be a child of the grid.");			}						placedObjects = placedObjects.splice(position, 1);						dObj.scaleX = dObj.scaleY = 1;			dObj.x = dObj.y = 0;						_full = false;						refresh();		}				/**		*	Removes all elements from the grid.		*			*		*/		public function clear():void {			placedObjects = [];			_full = false;			refresh();		}				/**		*	Searches for an item in a grid by using strict equality ( === )		*	and returns the index position of the item.		*			*	@param	searchElement	The item to find in the grid.		*	@return	A zero-based index position of the item in the grid. 		*	If the <code>searchElement</code> argument is not found, the return value is -1.		*		*/		public function indexOf(searchElement:DisplayObject):int {			return placedObjects.indexOf(searchElement);		}				// PRIVATE & PROTECTED METHODS				protected function addCell(dObj:DisplayObject):void {						if (_full) {				return;			}						if (dObj.width > dObj.height) {				dObj.width = _cellWidth;				dObj.scaleY = dObj.scaleX;			} else {				dObj.height = _cellWidth;				dObj.scaleX = dObj.scaleY;			}						dObj.x = dObj.y = 0;			dObj.rotation = 0;						rectangle = dObj.getBounds(dObj);						arrange(dObj);						if (_columnsFirst) {				if ( ++_column > _maxColumns && _maxWidth > 0) {					_column = 0;					_row += 1;					_full = (_row > _maxRows && _maxHeight > 0);				}			} else {				if ( ++_row > _maxRows && _maxHeight > 0) {					_row = 0;					_column += 1;					_full = (_column > _maxColumns && _maxWidth > 0);				}			}						addChild(dObj);		}				private function arrange(dObj:DisplayObject):void {						dObj.x = _column * (_cellWidth + _spacing);			dObj.y = 	_row * (_cellWidth + _spacing);						if (_fill.indexOf(GridFill.RIGHT_TO_LEFT) != -1) {				dObj.x = _maxWidth  - dObj.x - cellWidth;			}						if (_fill.indexOf(GridFill.BOTTOM_TO_TOP) != -1) {				dObj.y = _maxHeight - dObj.y - cellWidth;			}						dObj.x +=  - (rectangle.x * dObj.scaleX) + (_cellWidth - dObj.width ) / 2;			dObj.y +=  - (rectangle.y * dObj.scaleY) + (_cellWidth - dObj.height) / 2;		}				private function refresh():void {						if (!ready) {				return;			}						var ike:int;			_row = _column = 0;			_full = false;						if (_maxWidth > 0) {				_maxColumns = (_maxWidth + _spacing) / (_cellWidth + _spacing) - 1;			}						if (_maxHeight > 0) {				_maxRows = (_maxHeight + _spacing) / (_cellWidth + _spacing) - 1;			}						while(numChildren) {				removeChildAt(0);			}						for (ike = 0; ike < placedObjects.length; ike += 1) {				addCell(placedObjects[ike]);			}		}	}}