package net.rezmason.display {		// IMPORT STATEMENTS	import flash.display.DisplayObject;	import flash.display.Shape;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;		import gs.TweenLite;	import com.robertpenner.easing.Quadratic;	import com.robertpenner.easing.Quintic;		public class DisplayObjectSlider extends Sprite {				// CLASS PROPERTIES		protected static const DEGREES_TO_RADIANS:Number = Math.PI / 180;		protected static const COMPLETE_EVENT:Event = new Event(Event.COMPLETE);				// INSTANCE PROPERTIES		protected var _busy:Boolean = false;				protected var _radius:Number, nextRadius:Number;		protected var tweenToObjects:Array = [{onComplete:finishTween}];		protected var _lastSubject:DisplayObject, _currentSubject:DisplayObject, nextSubject:DisplayObject;		protected var helperShape:Shape = new Shape;		protected var nextRect:Rectangle;		protected var transformMatrix:Matrix = new Matrix;		protected var nextCenter:Point = new Point;		protected var tweens:Array = [];		protected var container:Sprite = new Sprite;						public function DisplayObjectSlider(rad:Number = 100):void {			addChild(container);			mouseEnabled = false;			radius = rad;		}				// GETTERS & SETTERS				public function get radius():Number {			return _radius;		}				public function set radius(value:Number):void {			if (!isNaN(value)) {				_radius = value;			}		}				public function get busy():Boolean {			return _busy;		}				public function get lastSubject():DisplayObject {			return _lastSubject;		}				public function get currentSubject():DisplayObject {			return _currentSubject;		}				// PUBLIC METHODS				public function show(dObj:DisplayObject, standIn:Object = null, time:Number = 1, func:Function = null, angle:Number = 0):void {						var scratch:Number;						// don't do anything if you're in the middle of something			if (_busy || _currentSubject == dObj) {				return;			}						if (time < 0) {				time = 0;			}						_busy = true;			mouseChildren = false;						// set the tweening function			func ||= (Math.random() < 0.3) ? Quadratic.easeOut : Quintic.easeInOut;			try {				tweenToObjects[0].ease = func;			} catch (error:Error) {				tweenToObjects[0].ease = (Math.random() < 0.3) ? Quadratic.easeOut : Quintic.easeInOut;			}						nextSubject = dObj;			nextSubject.rotation = 0;			nextSubject.x = 0, nextSubject.y = 0;			nextSubject.scaleY = 1, nextSubject.scaleX = 1;						// we'll need to know the bounds of the next subject			nextRect = null;			if (standIn) {				if (standIn is Rectangle) {					nextRect = (standIn as Rectangle).clone();				} else if (standIn.x && standIn.y && standIn.width && standIn.height) {					with (helperShape.graphics) {						clear();						lineStyle(3);						drawRect(standIn.x, standIn.y, standIn.width, standIn.height);					}					nextRect = helperShape.getBounds(nextSubject);				}			}						if (!nextRect) {				nextRect = nextSubject.getBounds(nextSubject);			}						nextRadius = (nextRect.width * nextRect.width + nextRect.height * nextRect.height) * 0.25;			nextRadius = Math.pow(nextRadius, 0.5);						if (nextRadius > _radius) {				scratch = _radius / nextRadius;				nextSubject.width  *= scratch;				nextSubject.height *= scratch;				nextRect.width *= scratch;				nextRect.height *= scratch;				nextRect.x *= scratch;				nextRect.y *= scratch;				nextRadius = _radius;				trace(":(", "Your module was initially too big and had to be scaled down.");			}						nextCenter.x = nextRect.x + nextRect.width  / 2;			nextCenter.y = nextRect.y + nextRect.height / 2;						// the next subject has no rotation relative to the viewer, but appears two radii away 			//		in the direction indicated by the angle parameter						transformMatrix.identity();			transformMatrix.rotate(angle * DEGREES_TO_RADIANS);			transformMatrix.translate(2 * _radius, 0);			transformMatrix.rotate(-angle * DEGREES_TO_RADIANS);			transformMatrix.translate(-container.x, -container.y);						nextSubject.x = transformMatrix.tx - nextCenter.x;			nextSubject.y = transformMatrix.ty - nextCenter.y;						tweenToObjects[0].x = -transformMatrix.tx;			tweenToObjects[0].y = -transformMatrix.ty;						container.addChild(nextSubject);						tweens[0] = TweenLite.to(container, time, tweenToObjects[0]);			if (time == 0) {				fastForward();			}		}				public function fastForward():void {			if (_busy) {				_busy = false;				mouseChildren = true;								var ike:int = 0;								for (ike = 0; ike < tweens.length; ike += 1) {					tweens[ike].complete();				}								tweens = [];								dispatchEvent(COMPLETE_EVENT);				}		}				public function rewind():void {			if (_busy) {				_busy = false;				mouseChildren = true;				var ike:int, jen:int;				var tweenLiteObject:Object;								for (ike = 0; ike < tweens.length; ike += 1) {					// Gross! This stuff should be encapsulated.					for (jen = 0; jen < tweens[ike].tweens.length; jen += 1) {						tweenLiteObject = tweens[ike].tweens[jen];						tweenLiteObject.o[tweenLiteObject.p] = tweenLiteObject.s;					}					TweenLite.removeTween(tweens[ike]);				}								tweens = [];				container.removeChild(nextSubject);				nextSubject = null;				dispatchEvent(COMPLETE_EVENT);			}		}				// PRIVATE & PROTECTED METHODS				protected function finishTween(event:Event = null):void {						_busy = false;			mouseChildren = true;						if (_currentSubject) {				container.removeChild(_currentSubject);			}						_lastSubject = _currentSubject;			_currentSubject = nextSubject;			nextSubject = null;						dispatchEvent(COMPLETE_EVENT);		}	}}