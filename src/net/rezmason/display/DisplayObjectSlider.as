package net.rezmason.display {		// IMPORT STATEMENTS	import flash.display.DisplayObject;	import flash.display.Shape;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;		import gs.TweenLite;	import com.robertpenner.easing.Quadratic;	import com.robertpenner.easing.Quintic;		/**	*	Sprite that animates quickly sliding objects. Designed for use with game menus.	*		*	@author Jeremy Sachs	*	@langversion	ActionScript 3.0	*	@playerversion	Flash 9	*	@tiptext	*/	public class DisplayObjectSlider extends Sprite {				// CLASS PROPERTIES		protected static const DEGREES_TO_RADIANS:Number = Math.PI / 180;		protected static const COMPLETE_EVENT:Event = new Event(Event.COMPLETE);				// INSTANCE PROPERTIES		protected var _busy:Boolean = false;				protected var _radius:Number, nextRadius:Number;		protected var tweenToObjects:Array = [{onComplete:finishTween}];		protected var _lastSubject:DisplayObject, _currentSubject:DisplayObject, nextSubject:DisplayObject;		protected var helperShape:Shape = new Shape;		protected var nextRect:Rectangle;		protected var transformMatrix:Matrix = new Matrix;		protected var nextCenter:Point = new Point;		protected var tweens:Array = [];		protected var container:Sprite = new Sprite;				/**		*	Creates a DisplayObjectSlider object that you can use to animate sliding objects.		*			*	@param	rad	 The distance for objects to slide to the center.		*/		public function DisplayObjectSlider(rad:Number = 100):void {			addChild(container);			mouseEnabled = false;			radius = rad;		}				// GETTERS & SETTERS				/**		*	The distance for objects to slide to the center.		*		*/		public function get radius():Number {			return _radius;		}				/**		*	@private		*		*/		public function set radius(value:Number):void {			if (!isNaN(value)) {				_radius = value;			}		}				/**		*	Represents whether the DisplayObjectSlider is currently animating.		*	<p>While this value is true, the subjects of the DisplayObjectSlider		*	will not receive mouse events.</p>		*		*/		public function get busy():Boolean {			return _busy;		}				/**		*	The previous subject.		*	<p>This property maintains its value after the last subject has finished		*	its departure animation. It is intended to simplify the act of returning		*	to a previous menu.</p>		*		*/		public function get lastSubject():DisplayObject {			return _lastSubject;		}				/**		*	The current subject.		*	<p>This is the object that is or will soon be centered		*	on the DisplayObjectSlider.</p>		*		*/		public function get currentSubject():DisplayObject {			return _currentSubject;		}				// PUBLIC METHODS				/**		*	Initializes a new sliding animation for a new subject.		*			*	@param	dObj	The new subject.		*	@param	standIn	A Rectangle or compatible Object		*	that represents the bounds of the subject.		*	<p>This may be useful in situations where the natural bounds		*	of the new subject do not reflect the way in which		*	it should be presented.</p>		*	<p>A compatible Object must have x, y, width and height values.</p>		*	@param	time	 The number of seconds for the animation to take.		*	@param	func	 The easing function which is used with the animation.		*	@param	angle	 The angle from which the new subject slides in.		*		*/		public function show(dObj:DisplayObject, standIn:Object = null, time:Number = 1, func:Function = null, angle:Number = 0):void {						var scratch:Number;						// don't do anything if you're in the middle of something			if (_busy || _currentSubject == dObj) {				return;			}						if (time < 0) {				time = 0;			}						_busy = true;			mouseChildren = false;						// set the tweening function			func ||= (Math.random() < 0.3) ? Quadratic.easeOut : Quintic.easeInOut;			try {				tweenToObjects[0].ease = func;			} catch (error:Error) {				tweenToObjects[0].ease = (Math.random() < 0.3) ? Quadratic.easeOut : Quintic.easeInOut;			}						nextSubject = dObj;			nextSubject.rotation = 0;			nextSubject.x = 0, nextSubject.y = 0;			nextSubject.scaleY = 1, nextSubject.scaleX = 1;						// we'll need to know the bounds of the next subject			nextRect = null;			if (standIn) {				if (standIn is Rectangle) {					nextRect = (standIn as Rectangle).clone();				} else if (standIn.x && standIn.y && standIn.width && standIn.height) {					with (helperShape.graphics) {						clear();						lineStyle(3);						drawRect(standIn.x, standIn.y, standIn.width, standIn.height);					}					nextRect = helperShape.getBounds(nextSubject);				}			}						if (!nextRect) {				nextRect = nextSubject.getBounds(nextSubject);			}						nextRadius = (nextRect.width * nextRect.width + nextRect.height * nextRect.height) * 0.25;			nextRadius = Math.pow(nextRadius, 0.5);						if (nextRadius > _radius) {				scratch = _radius / nextRadius;				nextSubject.width  *= scratch;				nextSubject.height *= scratch;				nextRect.width *= scratch;				nextRect.height *= scratch;				nextRect.x *= scratch;				nextRect.y *= scratch;				nextRadius = _radius;				trace(":(", "Your module was initially too big and had to be scaled down.");			}						nextCenter.x = nextRect.x + nextRect.width  / 2;			nextCenter.y = nextRect.y + nextRect.height / 2;						// the next subject has no rotation relative to the viewer, but appears two radii away 			//		in the direction indicated by the angle parameter						transformMatrix.identity();			transformMatrix.rotate(angle * DEGREES_TO_RADIANS);			transformMatrix.translate(2 * _radius, 0);			transformMatrix.rotate(-angle * DEGREES_TO_RADIANS);			transformMatrix.translate(-container.x, -container.y);						nextSubject.x = transformMatrix.tx - nextCenter.x;			nextSubject.y = transformMatrix.ty - nextCenter.y;						tweenToObjects[0].x = -transformMatrix.tx;			tweenToObjects[0].y = -transformMatrix.ty;						container.addChild(nextSubject);						tweens[0] = TweenLite.to(container, time, tweenToObjects[0]);			if (time == 0) {				fastForward();			}		}				/**		*	Allows the currently running animation to be skipped.		*			*/		public function fastForward():void {			if (_busy) {				_busy = false;				mouseChildren = true;								var ike:int = 0;								for (ike = 0; ike < tweens.length; ike += 1) {					tweens[ike].complete();				}								tweens = [];								dispatchEvent(COMPLETE_EVENT);				}		}				/**		*	Allows the currently running animation to be canceled.		*			*/		public function rewind():void {			if (_busy) {				_busy = false;				mouseChildren = true;				var ike:int, jen:int;				var tweenLiteObject:Object;								for (ike = 0; ike < tweens.length; ike += 1) {					// Gross! This stuff should be encapsulated.					for (jen = 0; jen < tweens[ike].tweens.length; jen += 1) {						tweenLiteObject = tweens[ike].tweens[jen];						tweenLiteObject.o[tweenLiteObject.p] = tweenLiteObject.s;					}					TweenLite.removeTween(tweens[ike]);				}								tweens = [];				container.removeChild(nextSubject);				nextSubject = null;				dispatchEvent(COMPLETE_EVENT);			}		}				// PRIVATE & PROTECTED METHODS				protected function finishTween(event:Event = null):void {						_busy = false;			mouseChildren = true;						if (_currentSubject && _currentSubject.parent == container) {				container.removeChild(_currentSubject);			}						_lastSubject = _currentSubject;			_currentSubject = nextSubject;			nextSubject = null;						dispatchEvent(COMPLETE_EVENT);		}	}}