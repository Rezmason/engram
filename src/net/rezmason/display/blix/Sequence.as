/** * blix Library 1.0: bitmap augmentation * by Jeremy Sachs 9/30/2007 * * I have no blog, yet. When I have one, visit it.  * Maybe by then I'll have a new blix library. * * You may distribute this class freely, provided it is not modified in any way (including * removing this header or changing the package path). * * jeremysachs@rezmason.net *//* NAME: Sequence   PURPOSE: handles blitting process for blix objects * (NOTE: Sequence is a public abstract class, like DisplayObject) * properties of Sequence: * registrationPoint- returns a point at the "registration" of the Sequence * bitmapData- returns a clone of the current frame * totalFrames- the number of frames of the given size in the provided bitmap sequence * x and y- Overloaded. They are now always integers. *  * (NOTE: The blix library determines for itself the number of frames in your sequences: * it counts how many times it can tile a boundary Rectangle, which you pass to it.) *  */  package net.rezmason.display.blix{	import flash.display.BitmapData;	import flash.display.Graphics;	import flash.display.Shape;	import flash.events.TimerEvent;	import flash.geom.Matrix;	import flash.geom.Rectangle;	import flash.geom.Point;	import flash.utils.Timer;	public class Sequence extends Shape	{		internal static  const KEY:String = "hackMeIfYouMust";		private var calibrateEvent:BlixEvent = new BlixEvent(BlixEvent.CALIBRATED);		protected var _source:BitmapData;		protected var _rect:Rectangle;		private var init:Boolean = false;		protected var _registration:Point;		protected var dumbPoint:Point = new Point;		protected var maxFrames:int;		protected var gridWidth:int, gridHeight:int;		protected var frame:BitmapData, frame2:BitmapData;		private var _x:Number = 0, _y:Number = 0;		private var _dispatch:Boolean = false;				public function Sequence(key:String, source:BitmapData, rect:Rectangle, 		reg:Point = null, dispatch:Boolean = false):void		{			/* This key system "prevents" classes from instantiating Sequence			 * in the public namespace.			 */			if (key != KEY) {				throw new ArgumentError("ArgumentError: Error #2012: Sequence class cannot be instantiated.");			}			_source = source;			_rect = rect;			_dispatch = dispatch;			if (!reg) {				reg = new Point(_rect.width/2, _rect.height/2);			}			_registration = reg;			calibrate();			// initiation			drawFrame(0);			cacheAsBitmap = true;		}		private function calibrate() : void {			init = false;						// bitmap setup			frame = new BitmapData(_rect.width, _rect.height, true, 0);			frame2 = frame.clone();			graphics.clear();			graphics.beginBitmapFill(frame, new Matrix(1, 0, 0, 1, -_registration.x, -_registration.y), false, false);			graphics.drawRect(-_registration.x, -_registration.y, _rect.width, _rect.height);			graphics.endFill();			// grid check, frame counting			gridWidth = 0;			while ((gridWidth + 1) * _rect.width <= _source.width)			{				gridWidth++;			}			gridHeight = 0;			while ((gridHeight + 1) * _rect.height <= _source.height)			{				gridHeight++;			}			maxFrames = gridWidth * gridHeight;						if (_dispatch) {				dispatchEvent(calibrateEvent);			}			init = true;		}		protected function drawFrame(f:int, m:Matrix = null):void		{			frame.lock();			frame.fillRect(frame.rect, 0);			_rect.x = (f % gridWidth) * _rect.width;			_rect.y = (f - (f % gridWidth)) / gridWidth * _rect.height;			if (m) {				// uses copyPixels when possible				frame2.copyPixels(_source, _rect, dumbPoint);				frame.draw(frame2, m);			} else {				// if there's a matrix parameter, it has to use draw				frame.copyPixels(_source, _rect, dumbPoint);			}			frame.unlock();		}		public function get totalFrames():int		{			return maxFrames;		}		public override function get graphics():Graphics		{			/* Access to Sequence's graphics object is prevented once its			 * constructor is finished.			 */			if (!init) {				return super.graphics;			} else {				return null;			}		}		public function get frameBitmapData():BitmapData		{			// retruning a reference to the real source data would split the class open			return frame.clone();		}		public function copyPixelsTo(bd:BitmapData, p:Point=null):void		{			// not sure if this will ever be used, but oh well.			if (!p) {				p = dumbPoint.clone();			}			p.x += x, p.y += y;			bd.copyPixels(frame, frame.rect, p);		}		public function get rect():Rectangle {			return _rect.clone();		}		public function set rect( r:Rectangle ) : void { 			_rect = r; 			calibrate();		}		public function get registrationPoint():Point {			return _registration.clone();		}		public function set registrationPoint( p:Point ) : void {			_registration = p.clone();			calibrate();		}		public override function get x():Number {			return _x;		}		public override function get y():Number {			return _y;		}		public override function set x (n:Number):void {			if (!isNaN(n)) {				_x = n;				super.x = int(n);			}		}		public override function set y (n:Number):void {			if (!isNaN(n)) {				_y = n;				super.y = int(n);			}		}		public function get bitmapData():BitmapData {			return _source;		}		public function set bitmapData( bd:BitmapData ) : void { 			_source = bd;			calibrate();		}	}}