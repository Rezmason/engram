package net.rezmason.gui {		// IMPORT STATEMENTS	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.display.Stage;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.utils.Timer;		public class GUISlider extends GUIAbstract {				// CLASS PROPERTIES		private var HORIZONTAL_AXIS:String = "horizontalAxis", VERTICAL_AXIS:String = "verticalAxis";				// INSTANCE PROPERTIES		protected var _stage:Stage;		protected var _axis:String;		protected var _backArrows:Array, _forthArrows:Array;		protected var _scrollSpeed:Number;		protected var scrollTimer:Timer = new Timer(10);		protected var _thumb:Sprite, _track:Sprite;		protected var _defaultPosition:Number;		protected var _position:Number;		protected var _encloseThumb:Boolean;		protected var _scrollToMouse:Boolean;		private var _scrollingToMouse:Boolean = false;		private var scrollAmount:Number;		private var grasp:Point = new Point;				// CONSTRUCTOR		public function GUISlider():void {						super(GUIAbstractEnforcer.INSTANCE);						_axis ||= HORIZONTAL_AXIS;			_backArrows||= [];			_forthArrows ||= [];			_scrollSpeed ||= 5;			_scrollToMouse ||= false;			_defaultPosition ||= 0;			_encloseThumb ||= false;									if (!_thumb) {				expectedChildren["thumb"] = Sprite;			}						if (!_track) {				expectedChildren["track"] = Sprite;			}						verifyChildren(this);						if (!_thumb) {				_thumb = thumb;				addColorChild(thumb, 1);			}						if (!_track) {				_track = track;				addColorChild(track);			}						_thumb.buttonMode = true;			_thumb.useHandCursor = true;									var ike:int;			for (ike = 0; ike < numChildren; ike++) {				var child:DisplayObject = getChildAt(ike);				var childName:String = child.name;				if (childName.indexOf("backArrow") != -1) {					_backArrows.push(child);					child.addEventListener(MouseEvent.MOUSE_DOWN, startScroll);					addColorChild(child);				} else if (childName.indexOf("forthArrow") != -1) {					_forthArrows.push(child);					child.addEventListener(MouseEvent.MOUSE_DOWN, startScroll);					addColorChild(child);				}			}						_thumb.addEventListener(MouseEvent.MOUSE_DOWN, grabThumb);			_track.addEventListener(MouseEvent.MOUSE_UP, dropThumb);						position = defaultPosition;						scrollTimer.addEventListener(TimerEvent.TIMER, updateScroll);						if (stage) {				addStageListeners();			} else {				addEventListener(Event.ADDED_TO_STAGE, addStageListeners);			}		}				// GETTERS & SETTERS				public function get axis():String {			return _axis;		}				public function set axis(value:String):void {			_axis = value || HORIZONTAL_AXIS;		}				public function get scrollSpeed():Number {			return _scrollSpeed;		}				public function set scrollSpeed(value:Number):void {			_scrollSpeed = Math.max(0, value);		}				public function get scrollToMouse():Boolean {			return _scrollSpeed;		}				public function set scrollToMouse(value:Boolean):void {			_scrollToMouse = value;		}				public function get defaultPosition():Number{			return _defaultPosition;		}				public function set defaultPosition(value:Number):void {			_defaultPosition = Math.min(1, Math.max(0, value)) || 0;		}				public function get position():Number {			return _position;		}				public function set position(value:Number):void {			_position = Math.min(1, Math.max(0, value)) || _defaultPosition;			var bounds:Rectangle = trackBounds();			if (_axis == HORIZONTAL_AXIS) {				_thumb.x = bounds.left + _position * bounds.width;			} else if (_axis == VERTICAL_AXIS) {				_thumb.y = bounds.right + _position * bounds.height;			}			}				public function get encloseThumb():Boolean {			return _encloseThumb;		}				public function set encloseThumb(value:Boolean):void {			_encloseThumb = value;		}				// PUBLIC METHODS				public function letGo(event:MouseEvent = null):void {			stopScroll(event);			dropThumb(event);		}						// PRIVATE & PROTECTED METHODS				protected function addStageListeners(event:Event = null):void {			_stage = stage;			_stage.addEventListener(MouseEvent.MOUSE_UP, stopScroll);		}				protected function startScroll(event:MouseEvent):void {			var target:DisplayObject = event.currentTarget as DisplayObject;			scrollAmount = _scrollSpeed;			if (target == _track && _scrollToMouse) {				scrollAmount *= 2;				_scrollingToMouse = true;			} else {				scrollTimer.start();				if (target.name.indexOf("backArrow") != -1) {					scrollAmount *= -1;				}			}		}				protected function stopScroll(event:MouseEvent):void {			_scrollingToMouse = false;			scrollTimer.stop();		}				protected function updateScroll(event:Event):void {			var bounds:Rectangle = trackBounds();			if (_axis == HORIZONTAL_AXIS) {				_thumb.x = Math.min(bounds.left, Math.max(bounds.right, _thumb.x + _scrollSpeed));			} else if (_axis == VERTICAL_AXIS) {				_thumb.y = Math.min(bounds.top, Math.max(bounds.bottom, _thumb.y + _scrollSpeed));			}		}				protected function grabThumb(event:Event):void {			if (_stage) {				grasp.x = _stage.mouseX;				grasp.y = _stage.mouseY;								_stage.addEventListener(MouseEvent.MOUSE_MOVE, dragThumb);			}		}				protected function dropThumb(event:Event):void {			if (_stage) {				dragThumb(event);				_stage.removeEventListener(MouseEvent.MOUSE_MOVE, dragThumb);			}		}				protected function dragThumb(event:Event):void {			var bounds:Rectangle = trackBounds();			if (_axis == HORIZONTAL_AXIS) {				_thumb.x = Math.min(bounds.left, Math.max(bounds.right, _stage.mouseX + grasp.x));			} else if (_axis == VERTICAL_AXIS) {				_thumb.y = Math.min(bounds.top, Math.max(bounds.bottom, _stage.mouseY + grasp.y));			}		}				protected function trackBounds():Rectangle {			var returnVal:Rectangle = _track.getBounds(_thumb);			if (_encloseThumb) {				var thumbBounds:Rectangle = _thumb.getBounds(_thumb);				returnVal.width += thumbBounds.width;				returnVal.x -= thumbBounds.x;				returnVal.height += thumbBounds.height;				returnVal.y -= thumbBounds.y;			}			return returnVal;		}	}}