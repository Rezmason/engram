package net.rezmason.engram {		import flash.events.Event;		import net.rezmason.display.ColorSprite;	internal class Prompt extends ColorSprite {				// CLASS PROPERTIES		private static const ANGLE_RANGE:Number = 15;		internal static const DISAPPEAR:String = "disappear";				// INSTANCE PROPERTIES						private var alertBox:AlertGuts = new PromptGuts() as AlertGuts;		private var alertSurface:PromptSurface = new PromptSurface(500, 200);		private var _alertType:AlertType;		private var _palette:Array;				private var _title:String = "Err.";		private var _messsage:String = 			"Hmm.";		private var _leftButtons:Array = [			//{name:"ONE", 	func:function(){trace(1);}},			//{name:"TWO", 	func:function(){trace(2);}},			//{name:"THREE", 	func:function(){trace(3);}},			//{name:"FOUR", 	func:function(){trace(4);}},		], _rightButtons:Array = [			{name:"ENO", 	func:function(){trace(-1);}},			{name:"OWT", 	func:function(){trace(-2);}},			//{name:"EERHT", 	func:function(){trace(-3);}},			//{name:"RUOF", 	func:function(){trace(-4);}},		];				// CONSTRUCTOR		public function Prompt():void {							addChild(alertSurface);			addChild(alertBox);			addColorChild(alertSurface);			addColorChild(alertBox);						alertType = AlertType.PROBLEM;	//AlertType.DECISION;						show(_title, _messsage, _leftButtons, _rightButtons, 0, 0);						//alertSurface.addEventListener("mouseDown", function(e){startDrag();});			//alertSurface.addEventListener("mouseUp", function(e){stopDrag();});			alertBox.addEventListener(DISAPPEAR, disappear);						x = y = 200;		}				// GETTERS & SETTERS				public function get defaultAffirmative():GUIButton {			return alertBox.defaultAffirmative;		}				public function get defaultNegative():GUIButton {			return alertBox.defaultNegative;		}				internal function get alertType():AlertType {			return _alertType;		}				internal function set alertType(value:AlertType):void {			_alertType = value;			alertBox.symbol = _alertType.symbol;			_palette = GamePalette.ALERT_PALETTES[alertType.paletteIndex].slice();			alertBox.whiteText = !isBright(_palette[0]);			setColors(_palette);			alertSurface.textureAlpha = _alertType.textureAlpha;		}				// INTERNAL METHODS				internal function show(title:String = "", messsage:String = "", leftButtons:Array = null, 								rightButtons:Array = null, defaultAffirmative:String = null, defaultNegative:String = null):void {			alertBox.show(title, messsage, leftButtons, rightButtons, defaultAffirmative, defaultNegative);			alertBox.setColors(_palette);			alertSurface.redraw(alertBox.width + 2 * AlertGuts.MARGIN, alertBox.height + 2 * AlertGuts.MARGIN + AlertGuts.TOP_MARGIN);			rotation = (Math.random() - 0.5) * 2 * ANGLE_RANGE;			appear();		}				internal function resize(w:int, h:int):void {			alertSurface.redraw(w, h);		}				internal function rerez(ratio:Number = 1):void {			alertSurface.rerez(ratio);		}				// PRIVATE METHODS				private function isBright(color:uint):Boolean {			return ((color >> 16) & 0xFF) + ((color >> 8) & 0xFF) + (color & 0xFF) > 0xE0;		}				private function appear(event:Event = null):void {			trace("appear");			// you have the stage; use it		}				private function disappear(event:Event = null):void {			trace("disappear");			// you have the stage; use it		}	}}