package net.rezmason.engram {		// IMPORT STATEMENTS	import flash.display.BlendMode;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.display.StageQuality;	import flash.display.StageScaleMode;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.geom.Point;	import flash.filters.ColorMatrixFilter;	import flash.media.Sound;	import flash.media.SoundTransform;	import flash.media.SoundMixer;	import flash.utils.Timer;		import net.rezmason.display.ColorManager;	import net.rezmason.display.ColorSprite;	import net.rezmason.display.Moment;	import net.rezmason.engram.CommonSignals;	import net.rezmason.engram.display.*;	import net.rezmason.engram.media.SoundChannels;	import net.rezmason.engram.menus.MenuBase;	import net.rezmason.engram.modules.GameType;	import net.rezmason.gui.AlertData;	import net.rezmason.gui.GUIEvent;	import net.rezmason.gui.GUIManager;	import net.rezmason.gui.GUIWindowWidget;	import net.rezmason.media.SoundManager;	import net.rezmason.net.Syphon;	import net.rezmason.utils.HeavyEvent;	import net.rezmason.utils.isAIR;	import net.rezmason.utils.isMac;	public final class View extends Sprite {				// CLASS PROPERTIES		private static const RESOURCE_URL:String = "./resources/resources.swf";		private static const READY_EVENT:Event = new Event(Event.COMPLETE);				internal static const SLIDE_FINISHED:String = "slideFinished";		private static const SLIDE_FINISHED_EVENT:Event = new Event(SLIDE_FINISHED);				[Embed(source="../../../../resources/startupdialog.swf")]		private static const StartupDialog:Class;				private static const ARCADE_BLURB:String = "These are your installed modules. Choose which ones you'd like to play.";		private static const STUDIO_BLURB:String = "Let's see what you got, Picasso. Here, make your art palette."		private static const DRILL_BLURB:String = "Practice makes perfect. Choose which module you'd like to play.";				private static const BAD_DEVELOPER:String = "Yo, cupcake! Take your fucking mitts off my global sound transform!";		private static const BAD_DEVELOPER_ERROR:Error = new Error(BAD_DEVELOPER);				// INSTANCE PROPERTIES		private var crashing:Boolean = false;		private var _state:int = 0, _lastState:int = 0;		private var backgroundIndex:int;		private var currentModuleColor:int = 0;		private var clickPoint:Point = new Point();		private var menus:Object;		private var _modulePlayground:ColorSprite = new ColorSprite;		private var centerSprite:ColorSprite = new ColorSprite;		private var errorStatic:Moment;		private var mainMenu:MenuBase;		private var gameMenu:MenuBase;		private var gridMenu:MenuBase;		private var debugMenu:MenuBase;		private var intro:MenuBase;		private var settingsMenu:MenuBase;		private var aboutBox:MenuBase;		private var pausedMenu:MenuBase;		private var scoreInput:MenuBase;		private var scoreboard:MenuBase;		private var backdrop:WindowSurface;		private var moduleColorManager:ColorManager, guiColorManager:ColorManager;		private var windowButtons:GUIWindowWidget;		private var sounds:Object = {}, channels:Object = {}, loops:Object = {};		private var canvas:Canvas;		private var hexSlider:HexSlider;		private var _startup:Startup;		private var _startupDialog:DisplayObject;		private var _guiManager:GUIManager;		private var soundManager:SoundManager;		private var properSoundTransform:SoundTransform = new SoundTransform();		private var prompt:Prompt;		private var canvasFilter:ColorMatrixFilter = new ColorMatrixFilter([			0.5, 0.5, 0.5, 0, -0.5,			0.5, 0.5, 0.5, 0, -0.5,			0.5, 0.5, 0.5, 0, -0.5,			0, 0, 0, 1, 0,		]);		private var soundCheckTimer:Timer = new Timer(5000);		private var _ready:Boolean = false;		private var crashDump:CrashDump;		private var crashDumpTimer:Timer = new Timer(5);		private var methodMap:Object;				public function View():void {						methodMap = {				(CommonSignals.ZAP as String): zap,				(CommonSignals.REVEAL_DEBUG_BUTTON as String): revealDebugButton,				(CommonSignals.PROMPT as String): alertUser,				(CommonSignals.CRASH_DUMP as String): showCrashDump			}						if (stage) {				loadResources();			} else {				addEventListener(Event.ADDED_TO_STAGE, loadResources);			}		}				// GETTERS & SETTERS				internal function get ready():Boolean {			return _ready;		}				internal function get busy():Boolean {			return (hexSlider.busy || crashing);		}				internal function get promptOnscreen():Boolean {			return prompt.onscreen;		}				internal function get state():int {			return _state;		}				internal function get lastState():int {			return _lastState;		}				internal function get startup():Startup {			return _startup;		}				internal function get guiManager():GUIManager {			return _guiManager;		}				internal function get modulePlayground():ColorSprite {			return _modulePlayground;		}				// INTERNAL METHODS				internal function setGameType(type:String = null):String {						var returnVal:String;						switch (type) {				default :				case GameType.ARCADE :					backgroundIndex = 2;					returnVal = ARCADE_BLURB;				break;				case GameType.STUDIO :					backgroundIndex = 3;					returnVal = STUDIO_BLURB;				break;				case GameType.DRILL :					backgroundIndex = 1;					returnVal = DRILL_BLURB;				break;				case GameType.FUMIGATE :					backgroundIndex = 1; // for now				break;			}						guiColorManager.applyColors(GamePalette.MENU_PALETTES[backgroundIndex]);// for now			cycleColor(0);						return returnVal;		}				internal function interpretSettings(options:Object):void {						// adjust smoothing instantly			if (options.blnSmoothing) {				stage.quality = StageQuality.HIGH;			} else {				stage.quality = StageQuality.MEDIUM;			}			// turn on and off audio			properSoundTransform.volume = options.volume;			SoundMixer.soundTransform = properSoundTransform;						// check the screen size			if (stage.stageWidth != options.windowSize.width) {				_guiManager.resizeWindow(options.windowSize);			}		}				internal function interpretKey(keyVal:String, keyIsDown:Boolean = false):void {						if (busy) {				return;			}			if (prompt.onscreen) {				handleMenuDefaults(keyVal);			} else {				switch (hexSlider.currentSubject) {					case gameMenu :					if (keyIsDown) {						gameMenu.keyResponder(keyVal);						handleMenuDefaults(keyVal);					}					break;					case settingsMenu :					if (keyIsDown && !settingsMenu.listening) {						handleMenuDefaults(keyVal);					}					break;										case scoreInput :					if (keyIsDown && !scoreInput.listening) {						handleMenuDefaults(keyVal);					}					break;					default :					if (keyIsDown) {						handleMenuDefaults(keyVal);					}					break;				}			}		}				internal function setupMenus():void {						//stage.addEventListener(MouseEvent.CLICK, grabMousePoint, false, 0, true);			removeChild(_startup);			centerSprite.removeChild(_startupDialog);			addChild(centerSprite);			addChild(prompt);			centerSprite.addChild(canvas);			centerSprite.addChild(hexSlider);			prompt.addEventListener(Prompt.ONSCREEN, refuseMouse);			prompt.addEventListener(Prompt.OFFSCREEN, allowMouse);			hexSlider.addEventListener(Event.COMPLETE, afterHexSlider);						// get window and pause controls			windowButtons = makeWindowWidget();			_guiManager.registerWindowWidget(windowButtons);			windowButtons.offset = 12;			addChild(windowButtons);			windowButtons.addEventListener(GUIEvent.INTERRUPT, ditto);			_guiManager.addEventListener(GUIEvent.INTERRUPT, ditto);			_guiManager.addEventListener(GUIEvent.REREZ, adjustSize);			//windowButtons.addEventListener(GUIEvent.CLOSE_WINDOW, function(event:Event):void{});			centerSprite.addColorChild(windowButtons);						moduleColorManager.applyColors(GamePalette.MENU_PALETTES[0], 0);			guiColorManager.applyColors(GamePalette.MENU_PALETTES[0], 0);						addEventListener(HeavyEvent.HEAVY, interpretHeavy);		}				internal function show(viewType:int, instantly:Boolean = false, ...args):void {			_lastState = _state;			_state = viewType;						var speed:Number = (instantly ? 0 : 1.4);						soundManager.stopChannel(SoundChannels.MENUS);						if (!soundCheckTimer.running) {				soundCheckTimer.start();			}						switch (_state) {				case ViewStates.MAIN_MENU:					hexSlider.show(mainMenu, null, speed);					guiColorManager.applyColors(GamePalette.MENU_PALETTES[0]);					moduleColorManager.applyColors(GamePalette.MENU_PALETTES[0]);				break;				case ViewStates.GAME_MENU:					hexSlider.show(gameMenu, null, speed);				break;				case ViewStates.GRID_MENU:					gridMenu.prepare.apply(gridMenu, args);					hexSlider.show(gridMenu, null, speed);				break;				case ViewStates.DEBUG_MENU:					guiColorManager.applyColors(GamePalette.MENU_PALETTES[6]);					moduleColorManager.applyColors(GamePalette.MENU_PALETTES[6]);					hexSlider.show(debugMenu, null, speed);				break;				case ViewStates.SETTINGS_MENU:					soundCheckTimer.reset();					guiColorManager.applyColors(GamePalette.MENU_PALETTES[7]);					moduleColorManager.applyColors(GamePalette.MENU_PALETTES[7]);					settingsMenu.prepare.apply(settingsMenu, args);					hexSlider.show(settingsMenu, null, speed);				break;				case ViewStates.ABOUT_BOX:					soundManager.play("aboutSound");					guiColorManager.applyColors(GamePalette.MENU_PALETTES[5]);					moduleColorManager.applyColors(GamePalette.MENU_PALETTES[5]);					hexSlider.show(aboutBox, null, speed);				break;				case ViewStates.SCOREBOARD:					soundManager.play("scoresSound");					guiColorManager.applyColors(GamePalette.MENU_PALETTES[4]);					moduleColorManager.applyColors(GamePalette.MENU_PALETTES[4]);					scoreboard.prepare.apply(scoreboard, args);					hexSlider.show(scoreboard, null, speed);				break;				case ViewStates.EXHIBITION_INTRO:					soundManager.play("harumphSound");					hexSlider.show(intro, null, speed);					guiColorManager.applyColors(GamePalette.MENU_PALETTES[6]);					moduleColorManager.applyColors(GamePalette.MENU_PALETTES[6]);				break;				case ViewStates.GAME:					soundManager.stopChannel(SoundChannels.MENUS);					_state = ViewStates.GAME;					canvas.filters = [];					hexSlider.show(args[0], args[0].module.centerpiece, speed);					if (args[1]) {						cycleColor(currentModuleColor);						}				break;				case ViewStates.PAUSED_MENU:					guiColorManager.applyColors(GamePalette.MENU_PALETTES[backgroundIndex]);					moduleColorManager.applyColors(GamePalette.MENU_PALETTES[backgroundIndex]);					hexSlider.show(pausedMenu, null, speed);				break;				case ViewStates.SCORE_INPUT:					moduleColorManager.applyColors(GamePalette.MENU_PALETTES[backgroundIndex]);					scoreInput.prepare();					hexSlider.show(scoreInput, null, speed);				break;			}		}				internal function cycleColor(overload:int = -1, now:Boolean = false):void {						if (overload != -1) {				currentModuleColor = overload;			} else {				currentModuleColor = currentModuleColor + 1;			}						currentModuleColor %= GamePalette.COLOR_PALETTES.length;			moduleColorManager.applyColors(GamePalette.COLOR_PALETTES[currentModuleColor], (now ? 0 : 1000));		}				internal function alertUser(event:Event, alert:AlertData = null, type:AlertType = null, nearClick:Boolean = false):void {						if (event is HeavyEvent) {				alertUser.apply(this, (event as HeavyEvent).param);				return;			}						grabMousePoint();			prompt.alertType = type || AlertType.PROBLEM;			prompt.show(alert, (nearClick ? clickPoint : null));		}				// PRIVATE & PROTECTED METHODS				private function loadResources(event:Event = null):void {			removeEventListener(Event.ADDED_TO_STAGE, loadResources);						mouseEnabled = false;						stage.scaleMode = StageScaleMode.SHOW_ALL;			stage.tabChildren = stage.stageFocusRect = false;			stage.showDefaultContextMenu = false;			stage.focus = stage;			centerSprite.mouseEnabled = false;			centerSprite.x = stage.stageWidth / 2;			centerSprite.y = stage.stageHeight / 2;						moduleColorManager = new ColorManager(_modulePlayground);			guiColorManager = new ColorManager(centerSprite);			guiColorManager.applyColors(GamePalette.MENU_PALETTES[0], 0);						backdrop = new WindowSurface(stage.stageWidth, stage.stageHeight);			backdrop.cacheAsBitmap = true;			centerSprite.addColorChild(backdrop);			addChild(backdrop);			addChild(centerSprite);						_startup = new Startup();			_startupDialog = new StartupDialog as DisplayObject;			addChild(_startup);			centerSprite.addChild(_startupDialog);						Syphon.addEventListener(Event.COMPLETE, assignResources);			Syphon.load(RESOURCE_URL);		}				private function assignResources(event:Event):void {			Syphon.removeEventListener(Event.COMPLETE, assignResources);						stage.focus = stage;			stage.addEventListener(MouseEvent.MOUSE_UP, forceFocus, false, 0, true);						_guiManager = GUIManager.INSTANCE;			_guiManager.stage = stage;			soundManager = SoundManager.INSTANCE;						if (isAIR()) {				backdrop.addEventListener(MouseEvent.MOUSE_DOWN, _guiManager.moveWindow);			}						crashDump = new CrashDump();			GUIManager.disableAbstract = Scribble.scribbleOut;			GUIManager.enableAbstract = Scribble.removeScribble;			canvas = new Canvas;			canvas.scaleX = canvas.scaleY = 1.5;			canvas.mouseEnabled = canvas.mouseChildren = false;			hexSlider = new HexSlider(stage.stageWidth * 0.75, canvas, 0.2);			canvas.filters = [canvasFilter];			canvas.blendMode = BlendMode.MULTIPLY;						Syphon.registerFont("ProFont_9pt_st");			menus = {				(ViewStates.MAIN_MENU as int):mainMenu = fetchMenu("MainMenu"),				(ViewStates.GAME_MENU as int):gameMenu = fetchMenu("GameMenu"),				(ViewStates.GRID_MENU as int):gridMenu = fetchMenu("GridMenu"),				(ViewStates.DEBUG_MENU as int):debugMenu = fetchMenu("DebugMenu"),				(ViewStates.EXHIBITION_INTRO as int):intro = fetchMenu("ExhibitionIntro"),				(ViewStates.SETTINGS_MENU as int):settingsMenu = fetchMenu("SettingsMenu"),				(ViewStates.ABOUT_BOX as int):aboutBox = fetchMenu("AboutBox"),				(ViewStates.PAUSED_MENU as int):pausedMenu = fetchMenu("PausedMenu"),				(ViewStates.SCORE_INPUT as int):scoreInput = fetchMenu("ScoreInput"),				(ViewStates.SCOREBOARD as int):scoreboard = fetchMenu("Scoreboard")			};						for (var prop:String in menus) {				centerSprite.addColorChild(menus[prop]);			}			sounds.buttonSound = fetchSound("ButtonSound");			sounds.settingSound = fetchSound("SettingSound");			sounds.mispressSound = fetchSound("MispressSound");			sounds.entrySound = fetchSound("EntrySound");			sounds.errorSound = fetchSound("ErrorSound");						declareSoundGroup("TYPE", "TypeTakSound", "TypeTakaSound", "TypePunkaSound", "TypeTikaSound");			declareSoundGroup("MENUS", "ScoresSound", "HarumphSound", "PromptSound", "AboutSound");			declareSoundGroup("PEEL", "PeelSound", "StickerSound");			declareSoundGroup("AMP", "AmpBuzzSound", "AmpBuzzInSound", "AmpBuzzOutSound");			declareSoundGroup("AMP", "AmpFuzzSound", "AmpFuzzInSound", "AmpFuzzOutSound");						loops.ampBuzzSound = ["ampBuzzSound", "ampBuzzInSound", "ampBuzzOutSound"];			loops.ampFuzzSound = ["ampFuzzSound", "ampFuzzInSound", "ampFuzzOutSound"];						sounds.panicSound = fetchSound("PanicSound");			sounds.badDiskSound = fetchSound("BadDiskSound");						loops.panicSound = ["panicSound"];			loops.badDiskSound = ["badDiskSound"];						soundManager.enlistSounds(sounds, channels, loops);			errorStatic = new (Syphon.getClass("ErrorStatic")) as Moment;			errorStatic.blendMode = BlendMode.MULTIPLY;			errorStatic.width = stage.stageWidth;			errorStatic.scaleY = errorStatic.scaleX;			prompt = new Prompt(stage);			addChild(errorStatic);						soundCheckTimer.addEventListener(TimerEvent.TIMER, checkSoundMixer);						_ready = true;			dispatchEvent(READY_EVENT);		}				private function makeWindowWidget():GUIWindowWidget {			var returnVal:GUIWindowWidget;			if (isAIR()) {				if (isMac()) {					returnVal = new (Syphon.getClass("MacWindowWidget")) as GUIWindowWidget;				} else {					returnVal = new (Syphon.getClass("PeeCeeWindowWidget")) as GUIWindowWidget;				}			} else {				returnVal = new (Syphon.getClass("PauseWidget")) as GUIWindowWidget;			}			return returnVal;		}				private function checkSoundMixer(event:Event):void {			if (state == ViewStates.SETTINGS_MENU) {				return;			}			var soundTransform:SoundTransform = SoundMixer.soundTransform;			var valid:Boolean = true;			with (soundTransform) {				valid &&= (Math.abs(volume - properSoundTransform.volume) < 0.05);				valid &&= (Math.abs(leftToLeft - properSoundTransform.leftToLeft) < 0.05);				valid &&= (Math.abs(rightToRight - properSoundTransform.rightToRight) < 0.05);				valid &&= (Math.abs(leftToRight - properSoundTransform.leftToRight) < 0.05);				valid &&= (Math.abs(rightToLeft - properSoundTransform.rightToLeft) < 0.05);				valid &&= (Math.abs(pan - properSoundTransform.pan) < 0.05);			}			if (!valid) {				// GRRRRRRR!				SoundMixer.soundTransform = properSoundTransform;				throw BAD_DEVELOPER_ERROR;			}		}				private function handleMenuDefaults(keyVal:String):void {			if (prompt.onscreen) {				if (prompt.defaultNo && (keyVal == "ESCAPE" || keyVal == "`")) {					prompt.defaultNo.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_DOWN));					prompt.defaultNo.dispatchEvent(new MouseEvent(MouseEvent.CLICK));				} else if (prompt.defaultYes && keyVal == "ENTER") {					prompt.defaultYes.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_DOWN));					prompt.defaultYes.dispatchEvent(new MouseEvent(MouseEvent.CLICK));				}				return;			}						var currentMenu:MenuBase = hexSlider.currentSubject as MenuBase;			if (currentMenu) {				if (currentMenu.defaultNo && (keyVal == "ESCAPE" || keyVal == "`")) {					currentMenu.defaultNo.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_DOWN));					currentMenu.defaultNo.dispatchEvent(new MouseEvent(MouseEvent.CLICK));				} else if (currentMenu.defaultYes && keyVal == "ENTER") {					currentMenu.defaultYes.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_DOWN));					currentMenu.defaultYes.dispatchEvent(new MouseEvent(MouseEvent.CLICK));				}			}		}				private function afterHexSlider(event:Event = null):void {			if (_state == 1) {				canvas.filters = [];			} else {				canvas.filters = [canvasFilter];			}						dispatchEvent(SLIDE_FINISHED_EVENT);		}				private function grabMousePoint(event:Event = null):void {			clickPoint.x = mouseX;			clickPoint.y = mouseY;		}				private function refuseMouse(event:Event = null):void {			centerSprite.mouseChildren = false;		}				private function allowMouse(event:Event = null):void {			centerSprite.mouseChildren = true;		}				private function killMouse(event:Event = null):void {					}				private function reviveMouse(event:Event = null):void {					}				private function forceFocus(event:Event = null):void {			if (stage) {				stage.focus = stage;			}		}				private function fetchMenu(menuName:String):MenuBase {			return new (Syphon.getClass("net.rezmason.engram.menus." + menuName)) as MenuBase;		}				private function declareSoundGroup(channelName:String, ...soundNames):void {			var channel:int = SoundChannels[channelName];			var soundName:String;			for (var ike:int = 0; ike < soundNames.length; ike++) {				soundName = soundNames[ike].substr(0, 1).toLowerCase();				soundName += soundNames[ike].substr(1);				sounds[soundName] = fetchSound(soundNames[ike]);				channels[soundName] = channel;			}		}				private function fetchSound(soundName:String):Sound {			return new (Syphon.getClass(soundName)) as Sound;		}				private function adjustSize(event:Event = null):void {			backdrop.rerez(_guiManager.sizeRatio);			prompt.rerez(_guiManager.sizeRatio);			settingsMenu.rerez(_guiManager.sizeRatio);		}				private function showCrashDump(event:Event = null):void {			crashing = true;			addChild(crashDump);			vibrateCrashDump();			vibrateCrashDump();	// lame, I know, but for some reason this must be done			vibrateCrashDump();			crashDump.width = backdrop.width;			crashDump.scaleY = crashDump.scaleX;			crashDumpTimer.addEventListener(TimerEvent.TIMER, vibrateCrashDump);			crashDumpTimer.start();			soundManager.play("panicSound", 0.4);			soundManager.play("badDiskSound");		}				private function vibrateCrashDump(event:Event = null):void {						if (!stage) {				crashDumpTimer.stop();				soundManager.stopLoop("panicSound");				soundManager.stopLoop("badDiskSound");				return;			}						crashDump.x = int(Math.random() * 3);						if (!event || Math.random() > 0.95) {				crashDump.updateText();				crashDump.y = Math.random() * (stage.stageHeight - crashDump.height);			}		}				private function interpretHeavy(event:HeavyEvent):void {			var func:Function = (methodMap[event.flavor] as Function);			if (func != null) {				func(event);			}		}				private function zap(event:HeavyEvent = null):void {			errorStatic.play();			soundManager.play("errorSound");		}				private function revealDebugButton(event:Event = null):void {			soundManager.stopChannel(SoundChannels.MENUS);			gameMenu.prepare(true);		}				private function ditto(event:Event):void {			dispatchEvent(event);		}	}}