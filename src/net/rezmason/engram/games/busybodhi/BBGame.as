package net.rezmason.engram.games.busybodhi {		// IMPORT STATEMENTS	import flash.display.*;	import flash.events.*;	import flash.geom.*;		import net.rezmason.engram.modules.Game;	import net.rezmason.utils.Hat;		internal final class BBGame extends Game {				// INSTANCE PROPERTIES		private var _comboString:String, comboTime:int;		private var tracks:Array, crazyTrack:Track = new Track();		private var maxComboSize:int;				// PUBLIC METHODS				override public function reset(event:Event = null):void {			_comboString = "";			comboTime = 0;			tracks = [];			crazyTrack.clear();			addTrack();			maxComboSize = 0;					}				override public function gameOver():void {						super.gameOver();		}				public function debug():void {			/*			var combo:String = "!";			var grains:Array = [1, 2, 3, 4];			while (grains.length) {				var grain:int = int(Math.random() * grains.length);				combo = tracks[0].addCombo(grains[grain]);				if (combo == null) {					grains.splice(grain, 1);				} else {					trace(combo);				}			}			trace("_____________");			//tracks[0].spew();			*/		}				// INTERNAL METHODS				internal function addTrack():int {			var returnVal:int;			for (var ike:int = 0; ike < tracks.length + 1; ike++) {				if (!tracks[ike]) {					returnVal = ike;					break;				}			}			tracks[returnVal] = new Track();			return returnVal;		}				internal function removeTrack(trackIndex):void {			tracks[trackIndex].clear();			tracks.splice(trackIndex, 1);		}				internal function get numTracks():int {			return tracks.length;		}				internal function addCombo(trackIndex:int):String {			if (trackIndex < 0) {				return crazyTrack.addCombo(4);			}			return tracks[trackIndex].addCombo(2);		}				internal function push(beat:Beat):void {			if (_comboString.length) {				comboTime += beat.time;			}			_comboString += beat.key;		}				internal function cancelCombo():void {			_comboString = "";			comboTime = 0;			trace("canceled");		}		internal function get comboString():String {			return _comboString;		}				internal function findMatches(trackIndex:int, complete:Boolean = false):Array {			if (_comboString.length <= maxComboSize) {				var _matches:Array = crazyTrack.find(_comboString, complete);				if (trackIndex < 0) {					return _matches;				}				_matches.push.apply(null, tracks[trackIndex].find(_comboString, complete));				return _matches;			}			return [];		}	}}