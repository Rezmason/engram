package net.rezmason.engram.games.busybodhi {	internal class Track  {				// CLASS PROPERTIES		internal static const MAX_CELLS:int = 12;				// INSTANCE PROPERTIES		private var tree:ComboNode = ComboNode.plantTree();		private var nodeComboPool:Object = {};		private var tiles:Object = {}, numTiles:int = 0;		private var primaryTile:Tile, currentTile:Tile;		private var fallingSpeed:Number = 10;		private var difficultyLevel:int = 2;						internal function addCombo(length:int):String {			var node:ComboNode = tree.add(length);			if (node) {				nodeComboPool[node.combo] = node;				return node.combo;			}			return null;		}				internal function find(combo:String, complete:Boolean = false):Array {			return tree.find(combo, complete);		}				internal function removeCombo(combo:String):Boolean {			if (nodeComboPool[combo]) {				if (nodeComboPool[combo].removeAndCollapse()) {					nodeComboPool[combo] = undefined;					return true;				}			}			return false;		}				internal function clear():void {			tree.clear();		}				internal function spew():void {			var spew:Array = tree.allLeaves();			for (var ike:int = 0; ike < spew.length; ike++) {				trace(ike, spew[ike]);			}		}	}}internal class ComboNode {		// CLASS PROPERTIES	private static var unusedNodes:Array = [];		// INSTANCE PROPERTIES		internal var index:String = "";	internal var combo:String = "";	internal var parentNode:ComboNode;	internal var rootNode:ComboNode;	internal var a:ComboNode, b:ComboNode, c:ComboNode, d:ComboNode;	internal var numChildren:int = 0;	internal var availableSlots:Array = [];		private var kid:ComboNode, kidNames:Array = ["a", "b", "c", "d"];	private var ike:int;		internal function clear():void {		if (numChildren) {			for (ike = 0; ike < 4; ike++) {				kid = this[kidNames[ike]] as ComboNode;				if (kid != null) {					kid.clear();					this[kidNames[ike]] = null;				}			}		}		index = "";		combo = "";		numChildren = 0;		availableSlots[0] = 0;		if (rootNode != this) {			parentNode = null;			rootNode = null;		} else {			unusedNodes.push(this);		}	}		internal function find(address:String, complete:Boolean = false):Array {		if (address.length) {			kid = this[address.charAt(0)];			if (kid != null) {				return kid.find(address.substr(0), complete);			}			return [];		}				if (complete) {			return numChildren ? [] : [this];		}				return allLeaves();	}		internal function allLeaves():Array {		var returnVal:Array = [];		if (numChildren) {			for (ike = 0; ike < 4; ike++) {				kid = this[kidNames[ike]] as ComboNode;				if (kid != null) {					returnVal.push.apply(null, kid.allLeaves());				}			}		} else {			returnVal = [this];		}		return returnVal;	}		internal function removeAndCollapse():Boolean {		if (numChildren) {			return false;		}		if (parentNode) {			parentNode[index] = null;			if (!--parentNode.numChildren) {				parentNode.removeAndCollapse();			}		}		parentNode = null;		rootNode = null;		unusedNodes.push(this);		return true;	}		internal function add(level:int):ComboNode {		// if the level is zero,		if (level == 0) {			// this is the new leaf			return this;		}		// otherwise,		var probs:Array = [0, 0, 0, 0];		var total:int = 0;		// weight the four child nodes		for (ike = 0; ike < 4; ike++) {			kid = this[kidNames[ike]] as ComboNode;			if (kid != null) {				// weight = number of empty slots under node of depth level - 1				if (kid.availableSlots[level - 1] == undefined) {					kid.availableSlots[level - 1] = Math.pow(4, level - 1);				}				probs[ike] = kid.availableSlots[level - 1];			} else {				probs[ike] = Math.pow(4, level - 1);			}			total += probs[ike];		}		// pick a node randomly		var rand:Number = Math.random() * total;		for (ike = 0; ike < 4; ike++) {			if (rand < probs[ike]) {				kid = this[kidNames[ike]];				break;			}			rand -= probs[ike];		}		//Assert: if you didn't pick any of the four,		if (ike == 4) {			// you are full and you are the root node OR there is an error			trace("I must be the root, and I must be full!", this == rootNode);			return null;		}		// if the chosen node doesn't exist,		if (kid == null) {			// make a new child node			kid = this[kidNames[ike]] = makeNode(this);			numChildren++;			kid.index = kidNames[ike];			kid.combo = combo + kid.index;			var node:ComboNode = this, nodeIndex:int = 1;			while (node != rootNode) {				if (node.availableSlots[nodeIndex] == undefined) {					node.availableSlots[nodeIndex] = Math.pow(4, nodeIndex);				}				node.availableSlots[nodeIndex]--;				nodeIndex++;				node = node.parentNode;			}		}				// chosen node . add(level - 1)				return kid.add(level - 1);	}		internal static function plantTree():ComboNode {		return makeNode(null);	}		internal static function makeNode(parentNode:ComboNode = null):ComboNode {		var node:ComboNode = (unusedNodes.length ? unusedNodes.shift() : (new ComboNode()));		node.parentNode = parentNode || node;		node.rootNode = node.parentNode.rootNode || node;		node.availableSlots = [0];		return node;	}		public function toString():String {		return "leaf " + combo;	}}