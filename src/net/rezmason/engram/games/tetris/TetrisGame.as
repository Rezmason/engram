package net.rezmason.engram.games.tetris {		// IMPORT STATEMENTS	import flash.display.*;	import flash.events.*;	import flash.geom.*;		import net.rezmason.engram.modules.Game;	import net.rezmason.utils.Hat;		internal final class TetrisGame extends Game {				// CLASS PROPERTIES		private const ROW:Array =   [2,0,0,0,0,0,0,0,0,0,0,2];		private const FLOOR:Array = [2,2,2,2,2,2,2,2,2,2,2,2];		private const ROW_STRING:String = ROW.toString();		private const GRID_HEIGHT:int = 20 + 2 + 1;		private const GRID_WIDTH:int = ROW.length;		private const STARTING_POINT:Point = new Point(4, 0);		private const ZERO_POINT:Point = new Point;		private const PIECES:Array = Pieces.PIECES;		private const LONG_KICKS:Array = [WallKicks.LONG_CLOCKWISE, WallKicks.LONG_COUNTERCLOCKWISE];		private const SHORT_KICKS:Array = [WallKicks.SHORT_CLOCKWISE, WallKicks.SHORT_COUNTERCLOCKWISE];				private const NEW_PIECE_EVENT:TetrisEvent = new TetrisEvent(TetrisEvent.NEW_PIECE);		private const CLEARED_LINES_EVENT:TetrisEvent = new TetrisEvent(TetrisEvent.CLEARED_LINES);		private const FREEZING_EVENT:TetrisEvent = new TetrisEvent(TetrisEvent.FREEZING);		private const THAWED_EVENT:TetrisEvent = new TetrisEvent(TetrisEvent.THAWED);		private const HOLD_EVENT:TetrisEvent = new TetrisEvent(TetrisEvent.HOLD);		private const TSPIN_EVENT:TetrisEvent = new TetrisEvent(TetrisEvent.TSPIN);		private const BANG_EVENT:TetrisEvent = new TetrisEvent(TetrisEvent.BANG);		private const CRISIS_EVENT:TetrisEvent = new TetrisEvent(TetrisEvent.CRISIS);		private const CRISIS_AVERTED_EVENT:TetrisEvent = new TetrisEvent(TetrisEvent.CRISIS_AVERTED);		private const CLAP_ON_EVENT:TetrisEvent = new TetrisEvent(TetrisEvent.CLAP_ON);		private const CLAP_OFF_EVENT:TetrisEvent = new TetrisEvent(TetrisEvent.CLAP_OFF);				// INSTANCE PROPERTIES		private var _active:Boolean = false;		private var _holdLock:Boolean = false;		private var _ghostIsOld:Boolean = false;		private var _crisisIsImminent:Boolean = false;		private var _tetrisIsImminent:Boolean = false;		private var _currentPiece:int;		private var _currentAngle:int;		private var _holdPiece:int;		private var _tSpin:int = 0;		private var _gameGrid:Array;		private var _currentPoints:Array = new Array;		private var _nextPieces:Array = new Array;		private var _fullRows:Array = new Array;		private var _queue:Array = new Array;		private var _index:Point = new Point;		private var _ghost:Point;		private var _hat:Hat = new Hat(7);				// GETTERS & SETTERS				internal function get grid():Array {			return _gameGrid.slice().reverse();		}				internal function get currentPoints():Array {			return _currentPoints.slice();		}				internal function get currentPiece():int {			return _currentPiece;		}				internal function get currentAngle():int {			return _currentAngle;		}				internal function get index():Point {			return _index.clone();		}				internal function get ghost():Point {			if (_ghostIsOld) {				_ghostIsOld = false;				_ghost = _index.clone();				while (!collides(_ghost, Shifts.DOWN_POINT, _currentPoints)) {					_ghost = _ghost.add(Shifts.DOWN_POINT);				}			}			return _ghost;		}				internal function get active():Boolean {			return _active;		}				internal function get fullRows():Array {			return _fullRows.slice();		}				internal function get holdPiece():int {			return _holdPiece;		}		internal function get nextPieces():Array {			return _nextPieces.slice();		}				// PUBLIC METHODS				override public function reset(event:Event = null):void {			_gameGrid = [FLOOR.slice()];			while (_gameGrid.length - GRID_HEIGHT < 0) {				_gameGrid.unshift(ROW.slice());			}						_index = new Point;			_ghost = new Point;			_currentPiece = 0;			_currentAngle = 0;			_currentPoints = [];			_nextPieces = [];			_holdPiece = -1;			_holdLock = false;			_ghostIsOld = false;			_fullRows = [];			_active = false;			_queue = [];			_crisisIsImminent = false;			_tetrisIsImminent = false;						_hat.reset(7);		}				override public function gameOver():void {			_active = false;			super.gameOver();		}				public function debug():void {			_gameGrid = 			[				[2,5,5,5,5,5,5,5,5,5,0,2],				[2,5,5,5,5,5,5,5,5,5,0,2],				[2,5,5,5,5,5,5,5,5,5,0,2],				[2,5,5,5,5,5,5,5,5,5,0,2],				FLOOR.slice(),			];						while (_gameGrid.length - GRID_HEIGHT < 0) {				_gameGrid.unshift(ROW.slice());			}		}				// INTERNAL METHODS				internal function fallCycle(event:Event = null):void {			if (_active) {				if (shift(Shifts.DOWN_POINT) == false) {					dispatchEvent(FREEZING_EVENT);				} else {					dispatchEvent(THAWED_EVENT);				}			}		}				internal function newPiece(event:Event = null, stopHolding:Boolean = true):void {			_active = true;						if (stopHolding) {				_holdLock = false;			}			while (_nextPieces.length < 4) {				_nextPieces.push(_hat.pick());			}			_currentPiece = _nextPieces.shift();						setupPiece(_queue.length > 0);						// _queue code. Lets actions be "recorded" for playback later.			var item:Array, fn:Function;			while (_queue.length) {				item = _queue.shift();				fn = item[0];				fn.apply(this, item.slice(1));				if (fn == hold && !_holdLock) {					break;				}			}					}				internal function freeze(event:Event = null):void {			if (!_active) {				return;			}			if (collides(index, Shifts.DOWN_POINT, _currentPoints)) {				dispatchEvent(BANG_EVENT);				_active = false;				solidify();				checkLines();				if (event && !_fullRows.length && _index.y == 0) {					gameOver();					return;				} else if (_tSpin) {					TSPIN_EVENT.tSpin = _tSpin;					_tSpin = 0;					dispatchEvent(TSPIN_EVENT);				}			}		}				internal function clearLines(event:Event = null):void {			var ike:int;			for (ike = 0; ike < _fullRows.length; ike += 1) {				_gameGrid.splice(_fullRows[ike], 1);				_gameGrid.unshift(ROW.slice());			}			_fullRows = [];			NEW_PIECE_EVENT.tSpin = _tSpin;			_tSpin = 0;			dispatchEvent(NEW_PIECE_EVENT);		}				internal function hold():void {			if (!_active) {				_queue.push([hold]);				return;			}			var ike:int;			if (!_holdLock) {				_holdLock = true;				if (_holdPiece == -1) {					_holdPiece = _currentPiece;					newPiece(null, false);				} else {					ike = _currentPiece;					_currentPiece = _holdPiece;					_holdPiece = ike;					setupPiece();				}				dispatchEvent(HOLD_EVENT);			}		}				internal function shift(stepPt:Point):Boolean {			if (!_active) {				if (stepPt.x) {					_queue.push([shift, stepPt]);				}				return true;			}			if (!collides(_index, stepPt, _currentPoints)) {				_index = _index.add(stepPt);				_ghostIsOld = true;								// check for a tetris scenario				tetrisCheck();								return true;			}			return false;		}				internal function slam():Boolean {			if (!_active) {				return false;			}			while (!collides(_index, Shifts.DOWN_POINT, _currentPoints)) {				_index = _index.add(Shifts.DOWN_POINT);			}			freeze();			return true;		}				internal function rotate(spin:String = Spins.CLOCKWISE):int {			if (!_active) {				_queue.push([rotate, spin]);				return 1;			}						var kicks:Array;			var testAngle = (_currentAngle + (spin == Spins.CLOCKWISE ? 1 : 3)) % 4;			var testPoints:Array = PIECES[_currentPiece][testAngle];			var ike:int, jen:int;						kicks = ((!_currentPiece ? LONG_KICKS : SHORT_KICKS) as Array)[spin == Spins.CLOCKWISE ? 0 : 1][testAngle];									for (ike = 0; ike < kicks.length; ike += 1) {				if (!collides(_index, kicks[ike], testPoints)) {					_currentPoints = testPoints;					_currentAngle = testAngle;					_index = _index.add(kicks[ike]);					_ghostIsOld = true;										// test for T-spin					if (_currentPiece == 3) {						var tBlocks:int = 0;						var point:Point = _index;						if (_gameGrid[point.y]) {							tBlocks += (_gameGrid[point.y    ][point.x    ] ? 1 : 0);							tBlocks += (_gameGrid[point.y    ][point.x + 2] ? 1 : 0);						}												if (_gameGrid[point.y + 2]) {							tBlocks += (_gameGrid[point.y + 2][point.x    ] ? 1 : 0);							tBlocks += (_gameGrid[point.y + 2][point.x + 2] ? 1 : 0);						}						if (tBlocks == 3) {							_tSpin = (ike == 0 ? 1 : 4);						}					}										// test for tetris column					tetrisCheck();										return (ike == 0 ? 1 : 2);				}			}						return 0;		}						// PRIVATE METHODS				private function setupPiece(ignoreCollision:Boolean = false):void {			_index = STARTING_POINT.clone();			_currentAngle = 0;			_currentPoints = PIECES[_currentPiece][_currentAngle];			_tSpin = 0;			_ghostIsOld = true;			if (!ignoreCollision && collides(_index, ZERO_POINT, _currentPoints)) {				gameOver();				return;			}			dispatchEvent(THAWED_EVENT);		}				private function collides(startPt:Point, stepPt:Point, points:Array):Boolean {			var point:Point;			var ike:int;						// for each point in the piece,			for (ike = 0; ike < points.length; ike += 1) {				// find the target space for that point in the gamegrid.				point = startPt.add(stepPt).add(points[ike]);				if (point.x > GRID_WIDTH - 1 || point.x < 0) {					// left or right wall collision					return true;				} else if (point.y > GRID_HEIGHT - 1 || point.y < 0) {					// floor collision					return true;				} else if (_gameGrid[point.y][point.x] != 0) {					// block collision					return true;				}			}			return false;		}				private function solidify():void {			var point:Point;			var ike:int;			for (ike = 0; ike < _currentPoints.length; ike += 1) {				point = _index.add(_currentPoints[ike]);				_gameGrid[point.y][point.x] = _currentPiece + 3;			}		}				private function checkLines():void {			var ike:int, jen:int;			var bravo:Boolean = true;			var str:String;			var highestRow:int = -1;						_fullRows = [];						// for each row,			for (ike = 0; ike < GRID_HEIGHT - 1; ike += 1) {				// if the current row has no empty spaces in it,				if (_gameGrid[ike].indexOf(0) == -1) {					// add it to the full list					_fullRows.push(ike);				} else {					// if the current row isn't empty,					str = _gameGrid[ike].toString();					if (str != ROW_STRING) {						// no bravo for you!						bravo = false;						if (highestRow == -1)						highestRow = ike;					}				}			}						// push the highest row down by the number of full rows			highestRow += fullRows.length;						// if there is a crisis and there's no reason,			if (_crisisIsImminent && (highestRow == -1 || highestRow > 7)) {				// end the crisis				_crisisIsImminent = false;				dispatchEvent(CRISIS_AVERTED_EVENT);			} else if (!_crisisIsImminent && highestRow < 4 && !bravo) {				// if there's no crisis and there should be, start a crisis				_crisisIsImminent = true;				dispatchEvent(CRISIS_EVENT);			}						if (_fullRows.length) {				CLEARED_LINES_EVENT.worth = _fullRows.length;				CLEARED_LINES_EVENT.tSpin = _tSpin;				CLEARED_LINES_EVENT.bravo = bravo;				_tSpin = 0;				dispatchEvent(CLEARED_LINES_EVENT);			} else {				NEW_PIECE_EVENT.tSpin = _tSpin;				_tSpin = 0;				dispatchEvent(NEW_PIECE_EVENT);			}		}				private function tetrisCheck():void {			var ike:int, jen:int, ken:int;			var point:Point = _index.clone();			var tRow:int = -1, tColumn:int = 0;						// it has to be an I-piece, angled sideways			if (_currentPiece == 0 && _currentAngle % 2) {				// find where the piece would rest				while (!collides(point, Shifts.DOWN_POINT, _currentPoints)) {					point = point.add(Shifts.DOWN_POINT);				}								point.x += (_currentAngle == 1 ? 2 : 1);								rows: for (ike = 0; ike < 4; ike += 1) {					columns: for (jen = 1; jen < GRID_WIDTH - 1; jen += 1) {						if (jen == point.x) {							continue columns;						}						if (!_gameGrid[ike + point.y][jen]) {							break rows;						}					}				}				if (ike == 4) {					tRow = point.y + 4 - 3;					tColumn = point.x - 1;				}			}						if (tRow != -1) {				if (!_tetrisIsImminent) {					_tetrisIsImminent = true;					CLAP_ON_EVENT.row = tRow;					CLAP_ON_EVENT.column = tColumn;					dispatchEvent(CLAP_ON_EVENT);				}			} else if (_tetrisIsImminent) {				_tetrisIsImminent = false;				dispatchEvent(CLAP_OFF_EVENT);			}					}	}}