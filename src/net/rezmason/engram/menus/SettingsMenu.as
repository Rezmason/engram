package net.rezmason.engram.menus {		// IMPORT STATEMENTS	import flash.display.InteractiveObject;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.text.TextFormatAlign;	import flash.ui.Keyboard;		import net.rezmason.gui.GUIButton;	import net.rezmason.gui.GUIBtnKey;	import net.rezmason.gui.GUICheckBox;	import net.rezmason.media.SoundManager;	import net.rezmason.utils.keyboardEventToString;		public class SettingsMenu extends MenuBase {				// INSTANCE PROPERTIES		private var listeningState:int = 0;		private var options:Object;		private var keyRef:Object;		private var usedKeys:Object;		private var currentGUIBtnKey:GUIBtnKey, currentCheckBox:GUICheckBox;		private var inputObject:InteractiveObject;		private var settingsManager:SettingsManager = SettingsManager.INSTANCE;		private var soundManager:SoundManager = SoundManager.INSTANCE;		private var _main:Main;				// CONSTRUCTOR		public function SettingsMenu(__main:Main):void {						_main = __main;						addColorChild(btnAKey);			addColorChild(btnBKey);			addColorChild(btnXKey);			addColorChild(btnLKey);			addColorChild(btnRKey);			addColorChild(btnUKey);			addColorChild(btnDKey);						addColorChild(btnDefaults);			addColorChild(btnReturn);			addColorChild(chxEffects);			addColorChild(chxColors);			addColorChild(chxAudio);			addColorChild(chxSmoothing);						btnDefaults.textAlign = TextFormatAlign.CENTER;						chxEffects.addEventListener(MouseEvent.CLICK, chxResponder);			chxColors.addEventListener(MouseEvent.CLICK, chxResponder);			chxAudio.addEventListener(MouseEvent.CLICK, chxResponder);			chxSmoothing.addEventListener(MouseEvent.CLICK, chxResponder);						btnAKey.value = ModuleKeySet.AKEY;			btnBKey.value = ModuleKeySet.BKEY;			btnXKey.value = ModuleKeySet.XKEY;			btnLKey.value = ModuleKeySet.LKEY;			btnRKey.value = ModuleKeySet.RKEY;			btnUKey.value = ModuleKeySet.UKEY;			btnDKey.value = ModuleKeySet.DKEY;						btnAKey.flag = btnAFlag;			btnBKey.flag = btnBFlag;			btnXKey.flag = btnXFlag;			btnLKey.flag = btnLFlag;			btnRKey.flag = btnRFlag;			btnUKey.flag = btnUFlag;			btnDKey.flag = btnDFlag;						btnAKey.addEventListener(MouseEvent.CLICK, setKey);			btnBKey.addEventListener(MouseEvent.CLICK, setKey);			btnXKey.addEventListener(MouseEvent.CLICK, setKey);			btnLKey.addEventListener(MouseEvent.CLICK, setKey);			btnRKey.addEventListener(MouseEvent.CLICK, setKey);			btnUKey.addEventListener(MouseEvent.CLICK, setKey);			btnDKey.addEventListener(MouseEvent.CLICK, setKey);						btnDefaults.addEventListener(MouseEvent.CLICK, defaults);			btnReturn.addEventListener(MouseEvent.CLICK, revertKey);			btnReturn.addEventListener(MouseEvent.CLICK, applySettings);						btnReturn.addEventListener(MouseEvent.CLICK, _main.interpretSettings);			btnReturn.addEventListener(MouseEvent.CLICK, _main.showLast);						_defaultYes = null;			_defaultNo = btnReturn;						init(_main.stage);		}				// GETTERS & SETTERS				public function get listening():Boolean {			return (listeningState != 0);		}				// PUBLIC METHODS				public function showModuleSlide():void {					}				// PRIVATE METHODS				private function init(io:InteractiveObject):void {						keyRef = {};			var keyMeanings:Object = settingsManager.keyMeanings;			for (var prop in keyMeanings) {				keyRef[keyMeanings[prop]] = prop;			}						options = settingsManager.options;			refreshKeys();			refreshCheckBoxes();						inputObject = io;			inputObject.addEventListener(KeyboardEvent.KEY_DOWN, keyResponder);			inputObject.addEventListener(KeyboardEvent.KEY_UP, resetListening);		}				private function applySettings(event:Event = null):void {						var keyMeanings:Object = {};			for (var prop in keyRef) {				keyMeanings[keyRef[prop]] = prop;			}			settingsManager.keyMeanings = keyMeanings;						settingsManager.options = options;		}				private function setKey(event:MouseEvent):void {						revertKey();						stage.focus = inputObject; // just being sure			currentGUIBtnKey = event.currentTarget as GUIBtnKey;			currentGUIBtnKey.text = "";			usedKeys[keyRef[currentGUIBtnKey.value]] = undefined;			currentGUIBtnKey.wait();			listeningState = 2;		}				private function revertKey(event:Event = null):void {			if (listeningState == 2) {				keyResponder(null, keyRef[currentGUIBtnKey.value]);			}		}				private function refreshCheckBoxes():void {			chxEffects.value    = options.blnEffects;			chxColors.value     = options.blnColors;			chxAudio.value      = options.blnAudio;			chxSmoothing.value  = options.blnSmoothing;		}				private function refreshKeys():void {						btnAKey.text = keyRef[ModuleKeySet.AKEY];			btnBKey.text = keyRef[ModuleKeySet.BKEY];			btnXKey.text = keyRef[ModuleKeySet.XKEY];			btnLKey.text = keyRef[ModuleKeySet.LKEY];			btnRKey.text = keyRef[ModuleKeySet.RKEY];			btnUKey.text = keyRef[ModuleKeySet.UKEY];			btnDKey.text = keyRef[ModuleKeySet.DKEY];						usedKeys = {};			usedKeys[keyRef[ModuleKeySet.AKEY]] = btnAKey;			usedKeys[keyRef[ModuleKeySet.BKEY]] = btnBKey;			usedKeys[keyRef[ModuleKeySet.XKEY]] = btnXKey;			usedKeys[keyRef[ModuleKeySet.LKEY]] = btnLKey;			usedKeys[keyRef[ModuleKeySet.RKEY]] = btnRKey;			usedKeys[keyRef[ModuleKeySet.UKEY]] = btnUKey;			usedKeys[keyRef[ModuleKeySet.DKEY]] = btnDKey;		}				private function defaults(event:Event = null):void {			revertKey();						settingsManager.defaults();						keyRef = {};			var keyMeanings:Object = settingsManager.keyMeanings;			for (var prop in keyMeanings) {				keyRef[keyMeanings[prop]] = prop;			}						options = settingsManager.options;						refreshKeys();			refreshCheckBoxes();		}		private function keyResponder(event:KeyboardEvent = null, oldValue:String = null):void {			if (listeningState == 2) {				var keyName:String;								if (event) {					keyName = keyboardEventToString(event);				} else {					keyName = oldValue;				}								if (!keyName || keyName == "TAB" || keyName == "ENTER") {					return;				}								if (keyName == "ESCAPE" || keyName == "`") {					revertKey();				} else if (usedKeys[keyName]) {					(usedKeys[keyName] as GUIBtnKey).triggerFlag();					soundManager.play("mispressSound");					_main.zap();				} else {						soundManager.play("entrySound");					usedKeys[keyRef[currentGUIBtnKey.value]] = undefined;					usedKeys[keyName] = currentGUIBtnKey;					keyRef[currentGUIBtnKey.value] = keyName;					currentGUIBtnKey.reset();					currentGUIBtnKey.text = keyName;					currentGUIBtnKey = null;					listeningState = 1;					stage.focus = stage;				}			}		}				private function resetListening(event:KeyboardEvent = null):void {			if (listeningState == 1) {				listeningState = 0;			}		}				private function chxResponder(event:MouseEvent):void {			currentCheckBox = event.currentTarget as LargeCheckBox;			switch (currentCheckBox) {				case chxColors:					options.blnColors = currentCheckBox.value;				break;				case chxEffects:					options.blnEffects = currentCheckBox.value;				break;				case chxAudio:					options.blnAudio = currentCheckBox.value;				break;				case chxSmoothing:					options.blnSmoothing = currentCheckBox.value;				break;			}		}	}}