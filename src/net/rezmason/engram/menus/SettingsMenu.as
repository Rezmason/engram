package net.rezmason.engram.menus {		// IMPORT STATEMENTS	import flash.display.InteractiveObject;	import flash.display.Sprite;	import flash.display.Stage;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.text.TextFormatAlign;	import flash.ui.Keyboard;		import net.rezmason.display.Moment;	import net.rezmason.engram.Main;	import net.rezmason.engram.SettingsManager;	import net.rezmason.engram.modules.ModuleKeyRoles;	import net.rezmason.gui.GUIButton;	import net.rezmason.gui.GUIBtnKey;	import net.rezmason.gui.GUICheckBox;	import net.rezmason.gui.GUIGroup;	import net.rezmason.media.SoundManager;	import net.rezmason.utils.keyboardEventToString;		public class SettingsMenu extends MenuBase {				// INSTANCE PROPERTIES		private var listeningState:int = 0;		private var options:Object;				private var keyRef:Object = {};		private var usedKeys:Object = {};				private var keyGroup:GUIGroup = new GUIGroup, btnKeys:Array;		private var currentGUIBtnKey:GUIBtnKey, currentCheckBox:GUICheckBox, currentFlag:Moment;		private var inputObject:InteractiveObject;		private var settingsManager:SettingsManager = SettingsManager.INSTANCE;		private var soundManager:SoundManager = SoundManager.INSTANCE;		private var _main:Main;		private var _stage:Stage;				// CONSTRUCTOR		public function SettingsMenu(__main:Main):void {						_main = __main;			_stage = _main.stage;			inputObject = _main.stage;						addColorChild(btnDefaults);			addColorChild(btnReturn);			addColorChild(chxEffects);			addColorChild(chxColors);			addColorChild(chxAudio);			addColorChild(chxSmoothing);						btnDefaults.textAlign = TextFormatAlign.CENTER;						chxEffects.addEventListener(MouseEvent.CLICK, chxResponder);			chxColors.addEventListener(MouseEvent.CLICK, chxResponder);			chxAudio.addEventListener(MouseEvent.CLICK, chxResponder);			chxSmoothing.addEventListener(MouseEvent.CLICK, chxResponder);						btnDefaults.addEventListener(MouseEvent.CLICK, defaults);			btnReturn.addEventListener(MouseEvent.CLICK, revertKey);			btnReturn.addEventListener(MouseEvent.CLICK, applySettings);						btnReturn.addEventListener(MouseEvent.CLICK, _main.interpretSettings);			btnReturn.addEventListener(MouseEvent.CLICK, _main.showLast);						_defaultYes = null;			_defaultNo = btnReturn;						keyGroup.addGUIAbstract(btnAKey);			keyGroup.addGUIAbstract(btnBKey);			keyGroup.addGUIAbstract(btnXKey);			keyGroup.addGUIAbstract(btnLKey);			keyGroup.addGUIAbstract(btnRKey);			keyGroup.addGUIAbstract(btnUKey);			keyGroup.addGUIAbstract(btnDKey);						btnKeys = keyGroup.keyChildren;			btnKeys.forEach(initKey);						var keyMeanings:Object = settingsManager.keyMeanings;			for (var prop in keyMeanings) {				keyRef[keyMeanings[prop]] = prop;			}						inputObject.addEventListener(KeyboardEvent.KEY_DOWN, keyResponder);			inputObject.addEventListener(KeyboardEvent.KEY_UP, resetListening);						options = settingsManager.options;			refreshKeys();			refreshCheckBoxes();		}				// GETTERS & SETTERS				public function get listening():Boolean {			return (listeningState != 0);		}				// PRIVATE METHODS				private function applySettings(event:Event = null):void {						var keyMeanings:Object = {};			for (var prop in keyRef) {				keyMeanings[keyRef[prop]] = prop;			}			settingsManager.keyMeanings = keyMeanings;						settingsManager.options = options;		}				private function initKey(target:GUIBtnKey, index:int, arr:Array):void {			addColorChild(target);			target.role = ModuleKeyRoles[target.name.substr(3).toUpperCase()];			target.flag = this[target.name.substr(0, 4) + "Flag"];			target.addEventListener(MouseEvent.CLICK, setKey);		}				private function setKey(event:MouseEvent):void {						revertKey();						stage.focus = inputObject; // just being sure			currentGUIBtnKey = event.currentTarget as GUIBtnKey;			usedKeys[keyRef[currentGUIBtnKey.role]] = undefined;			currentGUIBtnKey.pending = true;			listeningState = 2;		}				private function revertKey(event:Event = null):void {			if (listeningState == 2) {				currentGUIBtnKey.pending = false;				usedKeys[keyRef[currentGUIBtnKey.role]] = currentGUIBtnKey.role;			}		}				private function refreshCheckBoxes():void {			chxEffects.state    = options.blnEffects;			chxColors.state     = options.blnColors;			chxAudio.state      = options.blnAudio;			chxSmoothing.state  = options.blnSmoothing;		}				private function refreshKey(target:GUIBtnKey, index:int, arr:Array):void {			var targetRole:String = ModuleKeyRoles[target.name.substr(3).toUpperCase()];			target.char = keyRef[targetRole];			usedKeys[keyRef[targetRole]] = target;		}				private function refreshKeys():void {			usedKeys = {};			btnKeys.forEach(refreshKey);		}				private function defaults(event:Event = null):void {			revertKey();						settingsManager.defaults();						keyRef = {};			var keyMeanings:Object = settingsManager.keyMeanings;			for (var prop in keyMeanings) {				keyRef[keyMeanings[prop]] = prop;			}						options = settingsManager.options;						refreshKeys();			refreshCheckBoxes();		}		private function keyResponder(event:KeyboardEvent = null, oldValue:String = null):void {			if (listeningState == 2) {				var keyName:String;								keyName = keyboardEventToString(event);								if (!keyName || keyName == "TAB" || keyName == "ENTER") {					return;				}								if (currentFlag) {					currentFlag.stop();				}								if (keyName == "ESCAPE" || keyName == "`") {					revertKey();				} else if (usedKeys[keyName]) {					currentFlag = usedKeys[keyName].flag;					currentFlag.play();					soundManager.play("mispressSound");					_main.zap();				} else {						soundManager.play("entrySound");					usedKeys[keyRef[currentGUIBtnKey.role]] = undefined;					usedKeys[keyName] = currentGUIBtnKey;					keyRef[currentGUIBtnKey.role] = keyName;					currentGUIBtnKey.char = keyName;					currentGUIBtnKey = null;					listeningState = 1;					stage.focus = stage;				}			}		}				private function resetListening(event:KeyboardEvent = null):void {			if (listeningState == 1) {				listeningState = 0;			}		}				private function chxResponder(event:MouseEvent):void {			currentCheckBox = event.currentTarget as LargeCheckBox;			switch (currentCheckBox) {				case chxColors:					options.blnColors = currentCheckBox.state;				break;				case chxEffects:					options.blnEffects = currentCheckBox.state;				break;				case chxAudio:					options.blnAudio = currentCheckBox.state;				break;				case chxSmoothing:					options.blnSmoothing = currentCheckBox.state;				break;			}		}	}}