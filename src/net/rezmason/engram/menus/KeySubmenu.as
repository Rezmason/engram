package net.rezmason.engram.menus {		// IMPORT STATEMENTS	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;		import net.rezmason.engram.modules.ModuleKeyRoles;	import net.rezmason.gui.GUIBtnKey;	import net.rezmason.gui.GUIGroup;	import net.rezmason.media.SoundManager;	import net.rezmason.utils.keyboardEventToString;	public final class KeySubmenu extends Submenu {				// INSTANCE PROPERTIES		private var _listening:Boolean = false;		private var _keyGroup:GUIGroup = new GUIGroup, btnKeys:Array;		private var _keyPairs:Object;		private var soundManager:SoundManager = SoundManager.INSTANCE;						public function KeySubmenu(__settingsMenu:SettingsMenu):void {			super(__settingsMenu);						btnKeys = [				btnAKey, btnBKey, 				btnXKey, btnYKey, 				btnLKey, btnRKey, 				btnUKey, btnDKey,			];			btnKeys.forEach(initKey);									_settingsMenu.inputObject.addEventListener(KeyboardEvent.KEY_DOWN, keyResponder, false, 0, true);;			_settingsMenu.inputObject.addEventListener(KeyboardEvent.KEY_UP, resetListening, false, 0, true);;						btnDefault.addEventListener(MouseEvent.CLICK, defaultKeys);		}				// GETTERS & SETTERS				override internal function get description():String {			return "Click the buttons on the keypad above to set the corresponding keyboard control.";		}				internal function get listening():Boolean {			return _listening;		}				internal function get keyGroup():GUIGroup {			return _keyGroup;		}				internal function get keyPairs():Object {						_keyPairs = _keyGroup.keyPairs;						var inversePairs:Object = {};			for (var prop:String in _keyPairs) {				inversePairs[_keyPairs[prop]] = prop;			}						return inversePairs;		}				internal function set keyPairs(inversePairs:Object):void {			_keyPairs = {};			for (var prop:String in inversePairs) {				_keyPairs[inversePairs[prop]] = prop;			}		}				// PUBLIC METHODS				override internal function trigger(event:Event = null):void {					}				// INTERNAL METHODS				internal function syncKeys():void {			btnKeys.forEach(syncKey);			_keyGroup.syncKeys();		}				internal function revertKey(event:Event):void {			_keyGroup.listening = false;		}				// PRIVATE & PROTECTED METHODS				override protected function prepare(event:Event = null):void {					}				override protected function reset(event:Event = null):void {					}				private function ditto(event:Event):void {			dispatchEvent(event);		}				private function initKey(target:GUIBtnKey, index:int, arr:Array):void {			//addColorChild(target);			target.role = ModuleKeyRoles[target.name.substr(3).toUpperCase()];			target.flag = this[target.name + "Flag"];			target.addEventListener(MouseEvent.CLICK, listen);			_keyGroup.addGUIAbstract(target);		}				private function listen(event:MouseEvent):void {			_listening = true;			soundManager.play("typeTikaSound");		}				private function syncKey(target:GUIBtnKey, index:int, arr:Array):void {			target.char = _keyPairs[ModuleKeyRoles[target.name.substr(3).toUpperCase()]];		}				private function resetListening(event:KeyboardEvent = null):void {			if (_listening && !_keyGroup.listening) {				_listening = false;			}		}				private function defaultKeys(event:Event = null):void {			soundManager.play("typePunkaSound");			_keyGroup.listening = false;			_settingsMenu.defaultKeys();			syncKeys();		}				private function keyResponder(event:KeyboardEvent = null, oldValue:String = null):void {			if (_keyGroup.listening) {				var keyName:String;								keyName = keyboardEventToString(event);								if (keyName && keyName != "TAB" && keyName != "ENTER") {					if (keyName == "ESCAPE" || keyName == "`") {						_keyGroup.listening = false;						soundManager.play("typePunkaSound");					} else if (_keyGroup.tryKey(keyName)) {						soundManager.play("typeTakSound");					} else {						soundManager.play("mispressSound");						_settingsMenu.zap();					}				}			}		}	}}