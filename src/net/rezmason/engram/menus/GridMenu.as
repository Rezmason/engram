package net.rezmason.engram.menus {		// IMPORT STATEMENTS	import flash.display.InteractiveObject;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.filters.GlowFilter;	import flash.geom.Rectangle;	import flash.text.TextFormatAlign;		import net.rezmason.display.DisplayObjectSlider;	import net.rezmason.display.Grid;	import net.rezmason.engram.Controller;	import net.rezmason.engram.View;	import net.rezmason.engram.modules.ModuleLoader;		import com.robertpenner.easing.Quartic;		public final class GridMenu extends MenuBase {				// INSTANCE PROPERTIES		private var grids:Array = [];		private var loaders:Array = [];		private var enabledLoaders:Array = [];		private var slider:DisplayObjectSlider = new DisplayObjectSlider(500);		private var currentLoader:ModuleLoader;		private var glow:GlowFilter = new GlowFilter(0xFFFFFF, 0.8, 40, 40, 2, 1);		private var gridIndex:int = 0;		private var gridRect:Rectangle = new Rectangle(0, 0, 460, 272);		private var _controller:Controller;		private var _view:View;		private var _blurb:String = "";		private var _allowMultipleSelections:Boolean = false;		private var gridElements:Array = [];						public function GridMenu(__controller:Controller, __view:View):void {						_controller = __controller;			_view = __view;						super(true, false);						btnCancel.textAlign = TextFormatAlign.LEFT;			btnPlay.textAlign = TextFormatAlign.RIGHT;			updateInterface();						addChild(slider);						addColorChild(btnPrev);			addColorChild(btnNext);			addColorChild(btnPlay);			addColorChild(btnCancel);						btnPrev.addEventListener(MouseEvent.CLICK, prevGrid);			btnNext.addEventListener(MouseEvent.CLICK, nextGrid);						slider.addEventListener(Event.COMPLETE, enableArrows);						btnCancel.addEventListener(MouseEvent.CLICK, __controller.showLast);			btnPlay.addEventListener(MouseEvent.CLICK, makeMix);						_defaultNo = btnCancel;			_defaultYes = btnPlay;		}				// GETTERS & SETTERS				public function set allowMultipleSelections(value:Boolean):void {			if (_allowMultipleSelections != value) {				_allowMultipleSelections = value;				updateInterface();			}		}				public function set blurb(value:String):void {			_blurb = value.toUpperCase();			txtDescription.text = _blurb;		}						// PUBLIC METHODS				override public function prepare(...args):void {			if (args.length) {				//(moduleLoaders, lastMix, allowMultipleSelections, blurb);				allowMultipleSelections = args[2] || _allowMultipleSelections;				blurb = args[3] || _blurb;				makeGrids(args[0], args[1]);			}		}				public function makeGrids(moduleLoaders:Array, lastMix:Array = null):void {			var ike:int;			var _icon:InteractiveObject;						for (ike = 0; ike < grids.length; ike += 1) {				grids[ike].clear();			}						loaders = moduleLoaders.slice();			enabledLoaders = [];						for (ike = 0; ike < moduleLoaders.length; ike += 1) {								while (grids[gridIndex] && grids[gridIndex].full) {					gridIndex += 1;				}								if (grids[gridIndex] == undefined) {					grids[gridIndex] = new Grid(gridRect.width, gridRect.height, 84, 10);				}								currentLoader = moduleLoaders[ike];				_icon = currentLoader.moduleIcon;				_icon.filters = [];				_icon.x = _icon.y = 0;								if (_allowMultipleSelections) {					if (!gridElements[ike]) {						gridElements[ike] = new GridMenuElement(new GridMenuMark);						addColorChild(gridElements[ike]);					}										if (lastMix && lastMix[ike]) {						enabledLoaders[ike] = true;					}										gridElements[ike].content = _icon;					grids[gridIndex].place(gridElements[ike]);										if (enabledLoaders[ike]) {						gridElements[ike].showMark();					}				} else {					grids[gridIndex].place(_icon);				}								_icon.addEventListener(MouseEvent.ROLL_OVER, showDescription);				_icon.addEventListener(MouseEvent.ROLL_OUT, hideDescription);				_icon.addEventListener(MouseEvent.CLICK, clickResponder);				_icon.addEventListener(Event.ADDED, removeListeners);				_icon.addEventListener(Event.REMOVED, removeListeners);							}						for (ike = 0; ike < 50; ike += 1) {				while (grids[gridIndex] && grids[gridIndex].full) {					gridIndex += 1;				}								if (grids[gridIndex] == undefined) {					grids[gridIndex] = new Grid(gridRect.width, gridRect.height, 84, 10);				}								grids[gridIndex].place(new DefaultIcon);			}						gridIndex = 0;			slider.show(grids[gridIndex], gridRect, 0, Quartic.easeInOut);						btnPrev.enabled = (gridIndex != 0);			btnNext.enabled = (gridIndex != grids.length - 1);		}				// PRIVATE METHODS				private function getTargetIndex(event:Event):int {			var target:InteractiveObject = (_allowMultipleSelections ? event.currentTarget.parent : event.currentTarget) as InteractiveObject;			return gridIndex * grids[0].numChildren + grids[gridIndex].indexOf(target);		}				private function clickResponder(event:Event):void {			var index:int = getTargetIndex(event);			if (_allowMultipleSelections) {				if (enabledLoaders[index]) {					enabledLoaders[index] = false;					gridElements[index].hideMark();				} else {					enabledLoaders[index] = true;					gridElements[index].showMark();				}				playCheckBoxSound();			} else {				hideDescription(event);				_controller.startGame([loaders[index]]);			}		}				private function makeMix(event:Event):void {			var mix:Array = [];			var ike:int;						for (ike = 0; ike < enabledLoaders.length; ike++) {				if (enabledLoaders[ike] == true) {					mix.push(loaders[ike]);				}			}						if (mix.length) {				_controller.startGame(mix);			} else {				_view.zap();			}		}				private function showDescription(event:Event):void {						txtDescription.text = loaders[getTargetIndex(event)].moduleDescription;			event.currentTarget.filters = [glow];		}				private function hideDescription(event:Event):void {			txtDescription.text = _blurb;			event.currentTarget.filters = [];		}				private function updateInterface():void {						btnCancel.text = "BACK";			btnPlay.text = "LET'S GO"; // might want to randomize						btnPlay.visible = _allowMultipleSelections;						txtDescription.text = _blurb;		}				private function removeListeners(event:Event):void {			// not sure if this is enough			event.currentTarget.removeEventListener(MouseEvent.ROLL_OVER, showDescription);			event.currentTarget.removeEventListener(MouseEvent.ROLL_OUT, hideDescription);			event.currentTarget.addEventListener(MouseEvent.CLICK, clickResponder);			event.currentTarget.removeEventListener(Event.ADDED, removeListeners);			event.currentTarget.removeEventListener(Event.REMOVED, removeListeners);		}				private function prevGrid(event:MouseEvent):void {						if (gridIndex > 0) {				gridIndex--;				slider.show(grids[gridIndex], gridRect, 1, Quartic.easeInOut, 180);			}						btnPrev.enabled = (gridIndex != 0);			btnNext.enabled = (gridIndex != grids.length - 1);			btnPrev.mouseEnabled = btnNext.mouseEnabled = false;		}				private function nextGrid(event:MouseEvent):void {						if (gridIndex < grids.length - 1) {				gridIndex += 1;				slider.show(grids[gridIndex], gridRect, 1, Quartic.easeInOut);			}			btnPrev.enabled = (gridIndex != 0);			btnNext.enabled = (gridIndex != grids.length - 1);			btnPrev.mouseEnabled = btnNext.mouseEnabled = false;		}				private function enableArrows(event:Event):void {			btnPrev.mouseEnabled = btnNext.mouseEnabled = true;		}	}}