Diary:

5/20/08: A complicated API can be meticulously pieced apart and explored with impunity by creating a "testbed"- a simple scenario where you can prod it without affecting your main code.

5/21/08: If a system is offered to the public, and it is intended to work across bridges, it is the system developer's responsibility to not only make this work, but to completely encapsulate it, freeing the public from worrying about its functionality.

5/22/08: The difference between programming and computer science: 
Programming is the Writing of instructions. Like most other creative processes, it has a social component, although it is often overlooked. Programming, like architecture, has the capability to bring people together, to design rich and complex communities and societies. It primely intends to produce systems that solve problems on the social plane. In contrast, computer science is the Study of instructions. It intends to solve problems in computability and efficiency, and often forgoes the tasks of implementation and testing. Because of this, it does not approach the social plane, let alone intersect it. Although computer science benefits society, it does not cultivate society. An exception to this is the design of programming languages, an oddball so detached in its focus from its brethren that it very well may be a division of linguistics masquerading as a computer science.

5/23/08: Opening your source for free makes a statement. Treating people's contributions to your platform as untrustworthy makes a statement. Treating your own contributions as untrustworthy makes a statement.

"Chain reaction"-style recursive functions- the type of recursive function whose logic only affects lesser scopes- have the advantage of being transformable into a non-recursive function that pushes the recursive arguments onto a list with no public access to its interior elements (the ones that are not the first and last elements). Whereas all recursions can be transformed into iterations acting on a list, the behavior of "chain reaction" recursive functions guarantees that the traversal of this list can always proceed from the first element to the last, without backtracking. Since event systems and other implementations of the Observer pattern often use lists whose elements are processed from start to finish, a chain reaction can be rewritten to piggyback on top of the event system.

UPDATE: Piggybacking on the event system will actually cause a stack overflow in Flash, because functions that listen for events are considered to be in the scope of the function that dispatched the event. Other queues can still be used.

5/28/08: Working on this project while I'm on vacation has proven pretty much impossible. I'm beginning to wonder, based on my experience this week and during my last internship, whether I'll be able to put as much of my time into the project this summer as I hoped.

Tonight, after a short nap, I will begin a significant refactoring of my module loading code. Refactoring is undergone when code works but is poorly implemented; either it runs too slowly, it is inflexible, or its implementation is too convoluted to be understood. Tonight's refactoring (which would have been May 26th's refactoring) is not just the rewriting and rearranging of code, but the redefinition of classes and the roles that they play; the design is being improved on a higher level than simple logic structure. Because of this, I think "refactoring" is an insufficient label. What I'm doing is more akin to shuffling the employees of a company: promoting and demoting, hiring and firing entities that make up the company in order for it to run more smoothly. Fortunately I have no unions to worry about.

5/30/08: Reorganized all the code, and now everything looks and feels much better. The code is more presentable, and presentable code is important when you're sharing it with other people.

I'll be experimenting with a tweak to the color managing system that will allow nonuniform, gradual changes to occur in objects' coloration, rather than the current uniform, direct change. This may slow things down, so I'll probably have it trigger only if Effects are turned on in the Settings menu. (Edit: I ended up scrapping the nonuniform transition. There are other, more important things to implement.)

Speaking of which, the settings menu will need to be redone entirely soon, so that it can show more settings at once (probably by folding associated settings into categories, represented by tabs). I've got a whole interface planned out, which I'll get to later. Getting ahead of myself a bit, but that's never overburdened me before, has it?

5/31/08: Documentation probably should have begun months ago. The Mover class looks pretty alien, now that I'm trying to improve it. I'm hoping that documentation can occur in one fell swoop, just like the final going over where I'll check every namespace to ensure encapsulation; but the odds are at some point soon it will be costlier to stave off documentation than to get it over with, as arduous as it is. Also this is an indication that my coding style evolves with a frequency of at most six months.

6/5/08: I've started work at my summer internship, but progress on this project has continued. Last night at FCNY, Tom (the guy in charge I suppose) asked me to present my project at some point, so I'm going to write an outline covering the more interesting design decisions I've made over the past six months. No easy task.

While implementing GUIError this morning (it's thrown when GUI classes are misused), it occurred to me that not all of the module developers will have Strict Mode turned on, and although I'll suggest it, I can't anticipate that they will all use this feature. GUIError is actually redundant when using Strict Mode, but it's still a good idea to implement it.

Visio, a Microsoft Office product similar to OmniGraffle, is an industry standard for producing wireframes and prototypes- two powerful UX tools that I'm taking up at work. With no project currently demanding my time, I'm familiarizing myself with Visio by wireframing the new (read: intimidating) settings menu. I'm trying to be careful about how much of my work blends into my project, as this could lead to some hairy consequences. Nothing I can't handle.

6/6/08: Before working on the settings menu, I've decided to reorganize the current classes to relinquish some useful classes from the engram package. This will make them easier to use on projects independent of Engram. Tonight is a Friday night, so I'll have a chance to also improve the gui package (previously known as the ux package), expanding but also strengthening it with new interface elements and some foundation classes. I might be able to use the gui package to eventually create an advanced prototyping AIR app for the UX folks at Razorfish. They currently use several tools for prototyping, but none of them are absolutely ideal for the task; I think that the current means of automatically producing prototypes- flattening wireframes into tables and inserting links- falls short. Or maybe not. We'll see.

The GrimySurface class has received some more attention lately. It now sports what may be interpreted at first as a stray shoe print. Tonight I'll be asking forum folks and FCNY which tweening system I should use, in place of the built-in fl tween. This will allow more devs to contribute to the project, without forcing Flash CS3 onto them.

6/10/08: I've split the gritty texture and grimy texture segments of the GrimySurface class, so that they can be applied individually. This is because my friend and coworker Zak suggested an aesthetic change that I dismissed, but now can't stop thinking about. Unfortunately, I still haven't gotten the change to work, because it involves the complex world of fills and strokes, and how fills count and strokes don't (oftentimes).

Something I should have written about earlier is my style of development, which I call "stub-based". A "stub" is a mix between a placeholder and a traffic cone- it marks a point where progress was halted and resources redirected, but it encloses the incomplete work like a tarp over a construction site, protecting what's there until work can begin again. Stubs have two interesting incidental features; based on its implementation, a stub can communicate to the developer the level of abruptness reached when progress halted and the stub was made, and when a stub is removed and progress resumes, the point where the stub once was usually has a residual stubbiness to it. Stubs segment progress into observable chunks

I learned today that every statement made before the constructor is written gets broken down into two parts: the variable declaration (if there is one) and the rest of the statement. These statements are stuck in the beginning of the constructor, whether you realize it or not. So, if you have a subclass whose constructor sets the value of a protected property before calling the superclass's constructor, the superclass may set the value of the property back to what it is stated as in the superclass's variable declarations. Tricky tricky tricky.

6/18/08: Good news! My boss and mentor at my job have actually suggested that I find a portion of my thesis project to work on (among other things) during my internship. I'll be designing the developers' community site, based on what I'll research and design during the summer.

My classes have been separated into several packages, and I've extended a bunch of them to make them easier to use and more powerful. I'll soon have an Alert class, which will be a resizable object capable of displaying contextual messages to the user. I still need to redesign the settings menu, but I'm getting closer to the point where I'm ready to do so. I'll need to extend Mover (and possibly move it to the gui package, formerly the ux package) so that it can be set to move objects in multiple, controlled ways. I'm also removing all code dependencies on the Flash tween classes, including the tetris module, and I'm producing a ton of new gui elements. ModuleManager will need to be able to load a single module- the one it will receive when a module is dropped on the application- and eventually, it will need to include logic that decides which games to serve up and when.

12/31/08: A lot of time missing between this entry and the last one. The system for tweening menus has been modified to swap them between six fixed points on a hexagon that's centered around the new Canvas object, which parallaxes and rotates- that was all done months ago. Most recently, the grid system in the Drill menu has been repurposed to allow the player to specify the games in their mixes without going into the settings menu, which was the wrong place for them to begin with. Speaking of which, I still need to put the settings menu together. If I get my act together, I'll have it ready before the next semester begins (Jan. 12th), so I can concentrate on the more major parts of the game- the art system, the buffer system, and the MODULES THEMSELVES for crying out loud. I need to remember to allow time for user testing and devloping a promotional site.

1/4/09: Over the past three days, I created the prompt system. It's an alert box type of deal, except it has a dynamically textured window surface, a fluid layout, and oh yeah, it animates on and off the screen with a sticker peel effect. On the upside, I can now call a single function to communicate something contextual to the user. This means I won't have to make a Menu for everything under the sun. I'm going to migrate the Whine over to the prompt system as soon as possible.

1/8/09: I recently discovered that any DisplayObject subclass with public methods in the display list can be trawled for maliciously. Because of Flash Professional's way of building library symbols from public base classes, this means that I need to go the extra mile to prevent people from traversing my program's hierarchy- so code in Modules can't go up the tree, and code that loads in the entire app (like some sort of wrapper) can't go up the tree. Fortunately, the methods on DisplayObject and DisplayObjectContainer are can be overridden, which is just what I did.

That's allowed me to break the engram package up into several packages, which keeps things organized and lets me use the public namespace more often, which simplifies things. It's cool to know that folks will be able to read my project's inner classes, and could access them from a display list by themselves, but that altogether there is nothing they can do to compromise the entire system.

Prompt got done earlier in the week. The new GUI elements are next, and they'll be a lot of fun. Did I mention that I'm now working off a local SVN repository? I put it on my honking external drive, which has mirroring, so unless a stray communications satellite takes out my laptop AND my backup drive at the same time, I can work happily, secure in the knowledge that anything I mess up considerably can be undone. Twice. My working copy is also being backed up in Apple's Time Machine, should SVN decide to screw me.

Supplemental: After further securing Engram, I think I should put out some sort of dare to the Flash community, to see whether Engram really is secure and what I can do to make it even better. While I'm being paranoid, I should also profile this app at some point in Flex Builder. I can probably get that to work by embedding the complete Engram SWF in a Flex 3 AIR project. But right now, I want to get back to my GUI package.

1/9/09: I'm messing with the current (defunct) implementation of SettingsMenu, the new GUIOption class, GUIBtnKey and GUIGroup. Just like GUIGroup now handles the relationship between its GUIOption children, I want it to handle the same sort of relationship between BtnKey children. That means pulling some logic out of SettingsManager. GUIOption is like a radio button, where only one GUIOption in the group that it's assigned to can be picked at any given time. A natural subclass of GUIOption, then, is GUITab- a GUIOption with a text box. After putting GUITab together, though, I realized that there are some difficulties involved in writing a code subclass of GUIOption- difficulties that are probably present in all direct subclasses of GUIAbstract, because of the way that they anticipate the presence of display objects of certain data types and names. The problem comes from the automatic declaration feature in Flash CS4, which drives the gui package in the first place- by automatically creating variable declarations in GUIOption and GUITab from display objects in their related library symbols, Flash causes a compiler error to occur- the one about a subclass declaring variables already inherited from the superclass. I might want to rethink the way the GUIAbstract system works.

But first, I've got to finish the work I've been doing on GUIGroup and GUIBtnKey. Stay tuned.

1/11/09: Class resumes tomorrow. I've gotten GUIGroup to work as it should. GUITab looks nicer now, too. I've been working in GUITab on a direction to take GUIAbstract subclassing. My idea is, the superclass doesn't assign values to its working properties unless they're undefined when the constructor is called: prop ||= value; . The subclass then assigns values to those properties before calling super() in its constructor. The subclass does the same thing if it wants to have subclasses. So checking to see if a working property has a value is a way for code on a class to determine whether it is actually running on a subclass.

Do you know how many websites take "Flash cookies" for granted? They're a big deal- Flash maintains a cross-browser, systemwide store of data objects that it allows Flash instances to create by default. (SharedObjects, as they're called, are stored in a hashed directory, so an untrusted Flash app can't find another app's SharedObject.) Not everybody likes this behavior, so Flash has a somewhat squirreled away toggle that, when turned on, forces all Flash instances to ask politely each time they try to access or create their SharedObject, until they are finally granted permission. Some web apps ask many many times.

They shouldn't have to. One time should be enough, and their developers should know that. When the User denies an app's request for a SharedObject, the resulting SharedObject instance dispatches a NetStatusEvent, basically saying "No means NO." If the event isn't handled by the app, it shows up as an error in debug players (like mine). Surprisingly, most Flash apps don't throw the error, which implies that the app is listening to the event- it's just not using that information constructively.

What Engram now does is it records the denied request, and remembers not to ask again until the user quits the game. That's the best you can do. And that's what people should be doing in general.

I have two more GUI classes and three GUI elements to create- fun ones- before I finally get around to overhauling the settings menu, which I anticipate will take a week to put together. After that on my list is Gamepad Mode, which I'm not too excited about. I might postpone it, because it's the last item on the list before creating a new module, which I've put off for over a year now.

Maybe this stuff should be on a blog. I wonder if you can backlog a blog.

1/15/09: Tangents will be the end of me. I have two important obstacles between where I am and where I want to be (working on two Engram modules to have them done by the end of March). I need to get the settings menu done ASAP, which I think I can do today if I set my mind to it; then I need to finish implementing the Debug game type, which is a whole different can of worms. Waiting until I have another module to test with, I need to get the canvas system working and the strategy system. Also I'll need to allow the Studio mode to switch modules whenever... I wonder how I'll do that... maybe I'll make a dock on the right side of the game, that contains the icons of the loaded modules, and a "zoom out" button. Also a "Save" button, that'll pop open a dialog box. That should work fine.

Freaking tangents.

Later on, I'll need to patch up some holes that I've left for the sake of saving time, such as the module buffer system. I need to factor time into the project to do user testing as well.