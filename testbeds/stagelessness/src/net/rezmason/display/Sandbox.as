package net.rezmason.display{	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.InteractiveObject;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.utils.Dictionary;		import flash.geom.ColorTransform;	public final class Sandbox {		private static const MOUSE_EVENT_TYPES:Array = [		"click", 		"contextMenu", 		"doubleClick", 		"middleClick", 		"middleMouseDown", 		"middleMouseUp", 		"mouseDown", 		"mouseMove", 		"mouseOut", 		"mouseOver", 		"mouseUp", 		"mouseWheel", 		"rightClick", 		"rightMouseDown", 		"rightMouseUp", 		"rollOut", 		"rollOver", 		];		private var _singleAgent:Boolean;		private var _decayed:Boolean = false;		private var _dest:Sprite;		private var _src:DisplayObject;		private var registry:Dictionary = new Dictionary(true);		private var oldRects:Array;		private var rect:Rectangle;		private var signal:BitmapData		private var billboard:Bitmap = new Bitmap();				private var i:int;		private var par:DisplayObjectContainer;		private var kid:DisplayObject;		private var mat:Matrix = new Matrix();				public function Sandbox(src:DisplayObject, dest:Sprite, echoMouseEvents:Boolean = true, singleAgent:Boolean = true):void {			super();			_dest = dest || new Sprite();			_src = src || new Sprite();			_singleAgent = singleAgent;			if (echoMouseEvents) {				par = _src as DisplayObjectContainer;				var responder:Function = par ? tossComplex : toss;				for each (var type:String in MOUSE_EVENT_TYPES) {					_dest.addEventListener(type, responder);				}			}						_dest.addChild(billboard);			update();		}		public function decay():void {			_src = null;			registry = null;			_decayed = true;		}		private function tossComplex(event:MouseEvent):void {						var pt:Point = new Point(event.localX,event.localY);			var objects:Array = par.getObjectsUnderPoint(pt);			var tgt:DisplayObject,io:InteractiveObject;			outer:while (objects.length) {				tgt = objects.pop();				io = tgt as InteractiveObject || tgt.parent as InteractiveObject;				if (!io) continue;				if (tgt.parent == io && !(io as DisplayObjectContainer).mouseChildren) continue;				if (tgt == io && ! io.mouseEnabled) continue;				tgt = io;				inner:while (tgt.parent) {					if (! tgt.parent.mouseChildren) continue outer;					tgt = tgt.parent;				}				pt = io.globalToLocal(_dest.localToGlobal(pt));				event.localX = pt.x,event.localY = pt.y; // Is this correct?				io.dispatchEvent(event);				return;			}						toss(event);		}		private function toss(event:MouseEvent):void {			var pt:Point = new Point(event.localX,event.localY);			pt = _src.globalToLocal(_dest.localToGlobal(pt));			event.localX = pt.x,event.localY = pt.y;	// Is this correct?			_src.dispatchEvent(event);		}				private function refreshBitmap():void {			if (!signal || !signal.rect.containsRect(_src.getBounds(_dest))) {				signal = new BitmapData(_src.width, _src.height, true, 0x0);				billboard.bitmapData = signal;				oldRects = [signal.rect];			}		}		public function update(event:Event = null):void {			refreshBitmap();			for (i = 0; i < oldRects.length; i++) {				rect = oldRects[i];				signal.lock();				signal.fillRect(rect, 0x0);				signal.unlock(rect);			}			oldRects = [];									//signal.fillRect(signal.rect, 0xFF008000);						mat = _dest.transform.matrix;			mat.invert();			mat.concat(_src.transform.matrix);						for (i = 0; i < par.numChildren; i++) {				kid = par.getChildAt(i);				rect = kid.getBounds(par);				signal.lock();				signal.draw(_src, mat, null, null, rect);				signal.unlock(rect);				oldRects[i] = rect;			}		}	}}/*import flash.display.Bitmap;import flash.events.Event;import flash.utils.Dictionary;class Agent extends Bitmap {private static const EVOLVED:String = "Error: The Agent class does not implement this property.";private static const EVOLVED_ERROR:Error = new Error(EVOLVED, 2069);internal static const TAMPERED:String = "tampered";private static const TAMPERED_EVENT:Event = new Event(TAMPERED, true);private var index:int = -1;internal static var registry:Dictionary = new Dictionary(true);override public function get bitmapData():BitmapData { throw EVOLVED_ERROR; return null; }override public function set bitmapData(value:BitmapData):void { throw EVOLVED_ERROR; }override public function get pixelSnapping():String { throw EVOLVED_ERROR; return null; }override public function set pixelSnapping(value:String):void { throw EVOLVED_ERROR; }override public function get smoothing():Boolean { throw EVOLVED_ERROR; return null; }override public function set smoothing(value:Boolean):void { throw EVOLVED_ERROR; }public function Agent(src:DisplayObject):void {super();addEventListener(Event.ADDED, checkParent);}internal function checkParent(event:Event):void {if (!(parent is Sandbox)) {registry[this] = null;dispatchEvent(TAMPERED_EVENT);}}}*/