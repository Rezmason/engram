const FAT:Number = 0;var st = new SwirlTop, sb = new SwirlBottom;var sh = new Shadow, shMask = new SwirlTop;var stMask = new Mask, sbMask = new Mask;var marker = new Marker, target, lastX, lastY;var bottom = new Sprite, top = new Sprite;var bounds;var mat, mat2;var topLeft;var updateMasks = true;stMask.alpha = 0;sh.blendMode = BlendMode.MULTIPLY;addChild(top);addChild(bottom);top.addChild(st);top.addChild(stMask);top.addChild(sh);top.addChild(shMask);bottom.addChild(sb);bottom.addChild(sbMask);addChild(marker);sb.mouseEnabled = sbMask.mouseEnabled = stMask.mouseEnabled = false;marker.center.addEventListener("mouseDown", beginDrag);marker.pointer.addEventListener("mouseDown", beginDrag);st.addEventListener("mouseDown", beginDrag);stage.addEventListener("mouseUp", endDrag);shMask.x = st.x = stage.stageWidth / 2, shMask.y = st.y = stage.stageHeight / 2;marker.x = st.x, marker.y = st.y - 100;update();function beginDrag(e) {	target = e.currentTarget;	stage.addEventListener("mouseMove", update);}function endDrag(e) {	target = null;	stage.removeEventListener("mouseMove", update);}function update(e = null) {		if (target == marker.center) {		marker.x = mouseX;		marker.y = mouseY;	} else if (target == marker.pointer) {		marker.rotation = Math.atan2(mouseY - marker.y, mouseX - marker.x) * 180 / Math.PI;	} else if (target == st) {		shMask.rotation = st.rotation = Math.atan2(mouseY - st.y, mouseX - st.x) * 180 / Math.PI;	}			bounds = st.getBounds(marker);	bounds.x -= FAT, bounds.y -= FAT;	bounds.width += 2 * FAT, bounds.height += 2 * FAT;		// if the top is visible,	if (bounds.x <= 0) {		// show the top		top.visible = true;	} else {		// hide the top		top.visible = false;	}		bounds.width = Math.max(bounds.width + bounds.x, 0);	bounds.x = 0;		// if the bottom is visible,	if (bounds.width > 0) {		// show the bottom		bottom.visible = true;		// update the bottom		mat = st.transform.matrix.clone();		mat2 = marker.transform.matrix.clone();		mat2.invert();		mat.concat(mat2);		mat.a *= -1;		mat.c *= -1;		mat.tx *= -1;		mat.concat(marker.transform.matrix);		sb.transform.matrix = mat;	} else {		// hide the bottom		bottom.visible = false;	}		if (updateMasks) {		// update the masks		topLeft = this.globalToLocal(marker.localToGlobal(bounds.topLeft));		sh.rotation = sbMask.rotation = stMask.rotation = 0;		sh.width = sbMask.width  = stMask.width  = bounds.width;		sh.height = sbMask.height = stMask.height = bounds.height;		sbMask.scaleX *= -1, sh.scaleX *= -1;		sh.x = sbMask.x = stMask.x = topLeft.x;		sh.y = sbMask.y = stMask.y = topLeft.y;		sh.rotation = sbMask.rotation = stMask.rotation = marker.rotation;	}		// if the top and the bottom are visible,	if (bottom.visible && top.visible) {		// use the masks		if (!sb.mask) {			top.blendMode = BlendMode.LAYER;			stMask.blendMode = BlendMode.ALPHA;			sb.mask = sbMask;			sbMask.visible = stMask.visible = true;			sh.visible = true;			sh.mask = shMask;			shMask.visible = true;		}		// update the masks next time		updateMasks = true;	} else {		// don't use the masks						if (sb.mask) {			top.blendMode = BlendMode.NORMAL;			stMask.blendMode = BlendMode.NORMAL;			sb.mask = null;			sbMask.visible = stMask.visible = false;			sh.visible = false;			sh.mask = null;			shMask.visible = false;		}		// don't update the masks next time		updateMasks = false;	}}